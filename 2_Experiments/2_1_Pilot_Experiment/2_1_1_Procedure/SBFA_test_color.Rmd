---
title: "采用贝叶斯序列分析确定样本量"
date: "`r format(Sys.Date(), '%Y-%m-%d')`"
documentclass: ctexart
geometry: "left=2cm,right=2cm,top=2cm,bottom=2cm"
output:
  html_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
editor_options: 
  markdown: 
    wrap: 72
---

**markdown的内容：数据预处理 + BF 值计算**

-   数据预处理
    -   剔除极端值
    -   分组计算 RT, ACC, d prime
    -   将得到的数据以新的 csv 文件输出
-   BF 值计算

------------------------------------------------------------------------

-   研究中的关键效应

| 研究问题                                       | 统计假设                                                                                           | 因变量                              | 可能的 BF 值（加粗为关键）                                                         |
|-----------------|-----------------|-----------------|-----------------------|
| 自我关联是否对知觉判断中不同难度的试次产生影响 | 知觉难度与自我相关性的交互作用<br>知觉难度与自我相关性的交互作用<br>知觉难度与自我相关性的交互作用 | **RT**<br>ACC<br> ***d*** **prime** | **2×4 RM ANOVA 中的交互作用**<br>2×4 RM ANOVA 中的交互作用<br>**One way RM ANOVA** |

-   停止规则：
    -   贝叶斯因子阈值确定为10
    -   最小样本量40，最大样本量70

```{r}
rm(list = ls())
```

下载和安装需要的R语言程序包

```{r message=FALSE, warning=FALSE}
# install.packages(c("tidyverse", "BayesFactor", "here"))
library(BayesFactor)#计算t检验和方差分析的贝叶斯因子
library(tidyverse)
library(showtext)#解决中文字体无法显示问题
library(latex2exp)#latex语法
# font_add("song", 
         # "/System/Library/Fonts/Supplemental/Songti.ttc")
##从系统增加宋体字
showtext_auto()
library(here)
here()
options(scipen = 9)#将科学计数法改为在万后9位
set.seed(1234)
```

BayesFacotr包版本

```{r}
packageVersion("BayesFactor")
```

# 数据预处理

## 读取原始数据

```{r}
# 文件路径和文件名根据实际情况调整
# 设置目标文件夹相对路径
folder_path <- "../2_1_2_RawData/pilot_expt_all"

# 列出所有含有"pilot_expt_v4_"的csv文件
file_list <- list.files(
  path = folder_path,
  pattern = "*pilot_expt_0421_.*\\.csv$", full.names = TRUE
)

# 创建一个空列表来存储数据
df_list_1 <- list()

# 逐个读取文件并存储
for (file in file_list) {
  file_name <- tools::file_path_sans_ext(basename(file))  # 获取文件名（不带扩展名）
  df_list_1[[file_name]] <- read.csv(file)  # 将数据存储在列表中
}
#rm(file, file_list, folder_path)
```

## 数据清洗

```{r}
# 创建输出文件夹（如果不存在）
output_path <- "../2_1_3_CleanData/pilot_expt_all"
if (!dir.exists(output_path)) {
  dir.create(output_path, recursive = TRUE)
}

# 逐篇处理每个数据框
for (file_name in names(df_list_1)) {
  data <- df_list_1[[file_name]]

  # 提取被试信息
  participant_info <- data[data$part == "survey", "response"]
  participant_info <- gsub("[{}\"]", "", participant_info) # 去掉多余的字符
  info_list <- strsplit(participant_info, ",")[[1]]

  # 创建新的变量
  participant_data <- data.frame(
    subj_idx = file_name,
    Sex = as.character(NA),
    Age = as.numeric(NA),
    Handedness = as.character(NA),
    Color_blindness = as.character(NA),
    stringsAsFactors = FALSE
  )
  
  # 先按照下划线分割字符串
  split_data <- strsplit(participant_data$subj_idx, "_")
  # 提取分割后的第四个元素（数字部分在第四个位置，可根据实际调整）并转换为数值
  participant_data$subj_idx <- as.numeric(lapply(split_data, function(x) substr(x[[4]], 1, 2)))

  for (info in info_list) {
    key_value <- strsplit(info, ":")[[1]]
    key <- trimws(key_value[1])
    value <- trimws(key_value[2])
    if (key == "sex") participant_data$Sex <- value
    if (key == "age") participant_data$Age <- as.numeric(value)
    if (key == "hands") participant_data$Handedness <- value
    if (key == "color_blindness") participant_data$Color_blindness <- value
  }

  # 提取行为数据
  behavior_data <- data[
    data$part %in% c("motion_test","match_RDK","RDK"),
    c(
      "part", "rt", "response", "correct", "coherent_direction","coherence",
      "isMatch", "association", "difficulty", "dot_color_final","target_color_proportion"
    )
  ]
  
  # 分别提取正式试次
  official_trials <- do.call(
    rbind,
    lapply(unique(behavior_data$part), function(part) {
      part_data <- behavior_data[behavior_data$part == part, ]
      if (part == "match_RDK") {
        return(tail(part_data, 384)) # 匹配任务384次
      } else if (part == "RDK") {
        return(tail(part_data, 192)) # 辨别任务192次
      } else {
        return(NULL)
      }
    })
  )

  # 合并被试信息和行为数据
  final_data <- cbind(participant_data, official_trials)

  # 输出到新的CSV文件
  output_file <- file.path(output_path, paste0(file_name, "_Clean.csv"))
  write.csv(final_data, output_file, row.names = FALSE)
}
```

## 读取清洗后的数据

```{r message=FALSE}
# 设置目标文件夹相对路径
folder_path <- "../2_1_3_CleanData/pilot_expt_all"

# 列出所有含有"pilot_expt_"的csv文件
file_list <- list.files(
  path = folder_path,
  pattern = "*pilot_expt_0421_.*\\.csv$", full.names = TRUE
)

# 创建一个空列表来存储数据
df_list_1 <- list()

# 逐个读取文件并存储
for (file in file_list) {
  file_name <- tools::file_path_sans_ext(basename(file)) # 获取文件名（不带扩展名）
  df_list_1[[file_name]] <- read.csv(file) # 将数据存储在列表中
}

# 清除不需要的变量
rm(output_path, participant_info, info_list, participant_data, split_data,
   behavior_data, official_trials, final_data, output_file, file, file_list,
   file_name, folder_path, info, key, key_value, value)

# 把 df_list_1 传送给 data
data <- do.call(rbind, df_list_1)
```

## 分组计算RT, ACC

定义函数，用来计算不同条件下的平均反应时和正确率

```{r}
# 计算平均正确率和反应时
copmute_rt_acc <- function(data){
  data <- data %>%
  filter(part %in% c("match_RDK","RDK")) %>%
    group_by(subj_idx, part, difficulty, association) %>%  #按被试与难度和关联类型分组
    summarise(
      rt = mean(rt, na.rm = TRUE),#每个被试所有trial的平均反应时
      # rt_max = max(rt, na.rm = TRUE),#每个被试所有trial的最大反应时
      # rt_min = min(rt, na.rm = TRUE),#每个被试所有trial的最小反应时
      # sd_rt = sd(rt, na.rm = TRUE), #每个被试所有trial的反应时的方差
      # all_count = n(),#每个被试在每个条件的总trial数量
      # row_count = sum(rt >= 200 & rt <= 3000, na.rm = TRUE), #舍弃按键太快和按键太慢的反应时
      # correct_count = sum(correct == 'true' & rt >= 200 & rt <= 3000, na.rm = TRUE),
      acc = sum(correct == 'true' & rt >= 200 & rt <= 3000, na.rm = TRUE) / n(), #计算每个被试在每个条件的正确率= 正确/总数
      .groups = "drop")
   
    # 返回处理后的数据
    return(data)
}
```

```{r}
# 计算自我-他人的平均正确率和反应时
copmute_rt_acc_diff <- function(data){
  # 先按subj_idx, part, difficulty聚合，确保self和other数据在同一组内
  data_agg <- data %>%
    filter(part %in% c("match_RDK","RDK")) %>%
    group_by(subj_idx, part, difficulty) %>%
    summarise(
      rt_other = mean(rt[association == "other"], na.rm = TRUE),
      rt_self = mean(rt[association == "self"], na.rm = TRUE),
      acc_other = mean(acc[association == "other"], na.rm = TRUE),
      acc_self = mean(acc[association == "self"], na.rm = TRUE),
      .groups = "drop"
    )
  
  # 计算差值
  data_result <- data_agg %>%
    mutate(
      rt_diff_so = rt_self - rt_other,
      acc_diff_so = acc_self - acc_other
    )
  
  return(data_result)
}
```

```{r}
# 创建输出文件夹（如果不存在）
output_path <- "../2_1_3_CleanData/pilot_expt_all"
if (!dir.exists(output_path)) {
  dir.create(output_path, recursive = TRUE)
}

data <- data %>%
  #筛出反应时在200~3000)
  filter(rt >= 200 & rt <= 3000)

# color
data1 <- data %>%
  filter(
    subj_idx %in% c( seq(21, 40))) # 被试编号 21-40 为颜色组
              
data_color_rt_acc <- copmute_rt_acc(data1) %>%
  dplyr::mutate(group = "color") # %>%
  # tidyr::pivot_wider(names_from = c(part, difficulty, association), 
              #values_from = c(rt, acc))

data_color_rt_acc_diff <- copmute_rt_acc_diff(data_color_rt_acc)
```

## 数据整理

### 匹配任务

```{r}

# 创建输出文件夹（如果不存在）
output_path <- "../2_1_3_CleanData/pilot_expt_all"
if (!dir.exists(output_path)) {
  dir.create(output_path, recursive = TRUE)
}

df_color_match <- data_color_rt_acc %>% 
  filter(difficulty %in% c(1, 4), part %in% c('match_RDK')) %>%
  dplyr::select(subj_idx, acc, rt, association, difficulty, group) %>%
  #类型为character的转换为因子类型，便于后续分析
  mutate(subj_idx = as.factor(subj_idx),
         association = as.factor(association),
         difficulty = as.factor(difficulty))

# 输出到新的CSV文件
output_file <- file.path(output_path, "df_color_match.csv")
write.csv(df_color_match, output_file, row.names = FALSE)

df_color_diff_match <- data_color_rt_acc_diff %>%
  # 只选择难度为1 和 4 的
  filter(difficulty %in% c(1, 2, 3, 4),
         part %in% c('match_RDK')) %>%
  dplyr::select(subj_idx, acc_diff_so, rt_diff_so, difficulty) %>%
  #类型为character的转换为因子类型，便于后续分析
  mutate(subj_idx = as.factor(subj_idx),
         difficulty = as.factor(difficulty)) %>%
  tidyr::pivot_wider(
    names_from = difficulty,
    values_from = c(acc_diff_so, rt_diff_so),  # 同时处理acc和rt列
    names_glue = "{.value}_{difficulty}" ) 


  # 输出到新的CSV文件
  output_file <- file.path(output_path, "df_color_diff_match.csv")
  write.csv(df_color_diff_match, output_file, row.names = FALSE)

head(df_color_diff_match, 20)
```

#### 辨别任务

```{r}
df_color_rdk <- data_color_rt_acc %>% 
  filter(difficulty %in% c(1, 4), part %in% c('RDK')) %>%
  dplyr::select(subj_idx, acc, rt, association, difficulty, group) %>%
  #类型为character的转换为因子类型，便于后续分析
  mutate(subj_idx = as.factor(subj_idx),
         association = as.factor(association),
         difficulty = as.factor(difficulty))

# 输出到新的CSV文件
output_file <- file.path(output_path, "df_color_rdk.csv")
write.csv(df_color_rdk, output_file, row.names = FALSE)

df_color_diff_rdk <- data_color_rt_acc_diff %>%
  # 只选择难度为1 和 4 的
  filter(difficulty %in% c(1, 2, 3, 4), part %in% c('RDK')) %>%
  dplyr::select(subj_idx, acc_diff_so, rt_diff_so, difficulty) %>%
  #类型为character的转换为因子类型，便于后续分析
  mutate(subj_idx = as.factor(subj_idx),
         difficulty = as.factor(difficulty)) %>%
  tidyr::pivot_wider(
    names_from = difficulty,
    values_from = c(acc_diff_so, rt_diff_so),  # 同时处理acc和rt列
    names_glue = "{.value}_{difficulty}" ) 


# 输出到新的CSV文件
output_file <- file.path(output_path, "df_color_diff_rdk.csv")
write.csv(df_color_diff_rdk, output_file, row.names = FALSE)

head(df_color_diff_rdk, 20)
```

# BF 值计算
## 匹配任务
### 重复测量方差分析
####  ACC

数据的基本信息
```{r}
subj_num <- unique(df_color_match$subj_idx) # 每个被试的编号
n <- length(unique(df_color_match$subj_idx)) # 被试数量
n
```

检验交互项

生成三个向量用来储存两个主效应和交互项
```{r}
BFs_difficulty <- rep(1, length(subj_num))

BFs_association <- rep(1, length(subj_num))

BFs_int <- rep(1, length(subj_num))
```

**现在这个和JASP的结果基本一致**

```{r}
for (i in seq_along(subj_num)) {
  if (i == 1) {
    next
  }
  df_color_match$subj_idx <- as.character(df_color_match$subj_idx)
  id <- unique(df_color_match$subj_idx)[1:i]
  df.selected <- df_color_match %>% dplyr::filter(subj_idx %in% id)
  df.selected$subj_idx <- as.factor(df.selected$subj_idx)
  df.selected$difficulty <- as.factor(df.selected$difficulty)
  df.selected$association <- as.factor(df.selected$association)
  bayesfactors <- BayesFactor::anovaBF(
    acc ~ difficulty * association + subj_idx,
    data = data.frame(df.selected), 
    whichRandom = "subj_idx",
    # neverExclude = "subj_idx", 
    # whichModels = "all",
    rscaleFixed = 0.5,
    progress = FALSE)
  print(bayesfactors)
  
  # 计算association主效应的BF
  BFs_association[i] <- bayesfactors[3]/bayesfactors[2] 
  # 计算difficulty的BF
  BFs_difficulty[i] <- bayesfactors[3]/bayesfactors[1] 
  # 计算交互项的BF
  BFs_int[i] <- bayesfactors[4]/bayesfactors[3] 
}

aov_output <- tibble::tibble(BFs_int, BFs_association, BFs_difficulty)#整合为数据框
head(aov_output, 20)#查看数据
```


```{r}
str(bayesfactors)
```

```{r}
data_plot <- aov_output %>% dplyr::mutate(n = 1:nrow(.)) %>% 
  tidyr::pivot_longer(BFs_int:BFs_difficulty, names_to = "Effect", 
               values_to = "Bayes_Factor") %>% 
  # dplyr::mutate(`logBF` = log(`Bayes Factor`)) %>% 
  dplyr::mutate(dplyr::across(where(is.double), 
                              ~round(.x, digits = 2)))
head(data_plot, 20)
```

```{r}
data_plot %>% dplyr::filter(Effect == "BFs_int") %>% 
  ggplot(aes(x = n, y = Bayes_Factor)) + 
  geom_point(size = 3) + 
  geom_line() + 
  geom_hline(aes(yintercept = log(1)), linetype = "dashed")+
  geom_hline(aes(yintercept = log(10)), linetype = "dashed")+
  labs(y = TeX("$\\BF_{10} $")) + 
  ggtitle("交互作用的贝叶斯因子数值变化趋势 Match_ACC") + 
  # scale_y_continuous(
    # ) + 
   theme(
    panel.background = element_blank(),
    plot.margin = unit(c(1, 1, 1, 1), "cm"),
    plot.background = element_rect(fill = "white", color = NA),
    plot.title = element_text(size = 22, 
                              # family = "song",
                              face = "bold",
                              hjust = 0.5,
                              margin = margin(b = 15)),
    axis.line = element_line(color = "black", size = .5),
    axis.title = element_text(size = 18, color = "black",
                              face = "bold"),
    axis.text = element_text(size = 15, color = "black"),
    axis.text.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.ticks = element_line(size = 1),
    panel.grid = element_blank(),
    legend.position = c(0.20, 0.8),
    legend.background = element_rect(color = "black"),
    legend.text = element_text(size = 15),
    legend.margin = margin(t = 5, l = 5, r = 5, b = 5),
    legend.key = element_rect(color = NA, fill = NA))
# ggsave("RT_inx.png", width = 10, height = 7, dpi = 300)
```

#### RT

检验交互项

生成三个向量用来储存两个主效应和交互项
```{r}
BFs_difficulty <- rep(1, length(subj_num))

BFs_association <- rep(1, length(subj_num))

BFs_int <- rep(1, length(subj_num))
```

```{r}
for (i in seq_along(subj_num)) {
  if (i == 1) {
    next
  }
  df_color_match$subj_idx <- as.character(df_color_match$subj_idx)
  id <- unique(df_color_match$subj_idx)[1:i]
  df.selected <- df_color_match %>% dplyr::filter(subj_idx %in% id)
  df.selected$subj_idx <- as.factor(df.selected$subj_idx)
  df.selected$difficulty <- as.factor(df.selected$difficulty)
  df.selected$association <- as.factor(df.selected$association)
  bayesfactors <- BayesFactor::anovaBF(
    rt ~ difficulty * association + subj_idx,
    data = data.frame(df.selected), 
    whichRandom = "subj_idx",
    # neverExclude = "subj_idx", 
    # whichModels = "all",
    rscaleFixed = 0.5,
    progress = FALSE)
  print(bayesfactors)
  
  # 计算association主效应的BF
  BFs_association[i] <- bayesfactors[3]/bayesfactors[2] 
  # 计算difficulty的BF
  BFs_difficulty[i] <- bayesfactors[3]/bayesfactors[1] 
  # 计算交互项的BF
  BFs_int[i] <- bayesfactors[4]/bayesfactors[3] 
}

aov_output <- tibble::tibble(BFs_int, BFs_association, BFs_difficulty)#整合为数据框
head(aov_output, 20)#查看数据
```


```{r}
plot_rt <- aov_output %>% dplyr::mutate(n = 1:nrow(.)) %>% 
  tidyr::pivot_longer(BFs_int:BFs_difficulty, names_to = "Effect", 
               values_to = "Bayes_Factor") %>% 
  # dplyr::mutate(`logBF` = log(`Bayes Factor`)) %>% 
  dplyr::mutate(dplyr::across(where(is.double), 
                              ~round(.x, digits = 2)))
head(dat_plot, 20)
```


```{r}
plot_rt %>% dplyr::filter(Effect == "BFs_int") %>% 
  ggplot(aes(x = n, y = Bayes_Factor)) + 
  geom_point(size = 3) + 
  geom_line() + 
  geom_hline(aes(yintercept = log(1)), linetype = "dashed")+
  geom_hline(aes(yintercept = log(10)), linetype = "dashed")+
  labs(y = TeX("$\\BF_{10} $")) + 
  ggtitle("交互作用的贝叶斯因子数值变化趋势 Match_RT") + 
  # scale_y_continuous(
    # ) + 
   theme(
    panel.background = element_blank(),
    plot.margin = unit(c(1, 1, 1, 1), "cm"),
    plot.background = element_rect(fill = "white", color = NA),
    plot.title = element_text(size = 22, 
                              # family = "song",
                              face = "bold",
                              hjust = 0.5,
                              margin = margin(b = 15)),
    axis.line = element_line(color = "black", size = .5),
    axis.title = element_text(size = 18, color = "black",
                              face = "bold"),
    axis.text = element_text(size = 15, color = "black"),
    axis.text.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.ticks = element_line(size = .5),
    panel.grid = element_blank(),
    legend.position = c(0.20, 0.8),
    legend.background = element_rect(color = "black"),
    legend.text = element_text(size = 15),
    legend.margin = margin(t = 5, l = 5, r = 5, b = 5),
    legend.key = element_rect(color = NA, fill = NA))
```

### 配对样本T检验
假设：(self - other)easy 条件优于 (self - other)hard 条件

#### ACC

先建立一个空的列表，用来储存后续的贝叶斯因子。列表长度为目前数据的样本量

```{r}
bf_output <- rep(1, length(subj_num)) ### 先建立一个列表
```

```{r message=FALSE}
for (i in seq_along(subj_num)) {#i遍历subj_num
  if (i == 1) {
    next
    #由于一个被试不能正确计算贝叶斯因子，所以当i等于1时，跳过
  }
  #将df数据框中的subj_idx列转换为字符串型
  df_motion_diff_match$subj_idx <- as.character(df_motion_diff_match$subj_idx)
  #提取出遍历到的被试编号
  id <- unique(df_motion_diff_match$subj_idx)[1:i]
  #从原数据中筛选被试
  df.selected <- df_motion_diff_match %>% filter(subj_idx %in% id)
  #转换为因子型
  df.selected$subj_idx <- as.factor(df.selected$subj_idx)
  #计算贝叶斯因子
  bayesfactors <- ttestBF(df.selected$acc_diff_so_1,
                          df.selected$acc_diff_so_4, 
                          paired = TRUE, 
                          nullInterval = c(0, Inf))
  bf_output[i] <- bayesfactors[2]
}

aov_output <- tibble::tibble(bf_output)#整合为数据框
head(aov_output, 20)#查看数据
```

结果

```{r}
tibble(bf_output) %>% 
  dplyr::mutate(n = 1:nrow(.)) %>% 
  dplyr::rename("BayesFactor" = "bf_output") %>% 
  # dplyr::mutate(logBF = log(`Bayes Factor`)) %>% 
   ggplot(aes(x = n, y = `BayesFactor`)) + 
  geom_point(size = 3) + 
  geom_line() + 
  geom_hline(aes(yintercept = log(1)), linetype = "dashed") + 
  geom_hline(aes(yintercept = log(10)), linetype = "dashed") +
  labs(y = TeX("$\\BF_{10} $")) + 
  ggtitle("(self - other)easiest vs. (self - other)hardest Match_ACC") + 
   theme(
    panel.background = element_blank(),
    plot.margin = unit(c(1, 1, 1, 1), "cm"),
    plot.background = element_rect(fill = "white", color = NA),
    plot.title = element_text(size = 22, face = "bold",
                              hjust = 0.5,
                              margin = margin(b = 15)),
    axis.line = element_line(color = "black", size = .5),
    axis.title = element_text(size = 18, color = "black",
                              face = "bold"),
    axis.text = element_text(size = 15, color = "black"),
    axis.text.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.ticks = element_line(size = .5),
    panel.grid = element_blank(),
    legend.position = c(0.20, 0.8),
    legend.background = element_rect(color = "black"),
    legend.text = element_text(size = 15),
    legend.margin = margin(t = 5, l = 5, r = 5, b = 5),
    legend.key = element_rect(color = NA, fill = NA))
```


#### RT

```{r message=FALSE}
for (i in seq_along(subj_num)) {#i遍历subj_num
  if (i == 1) {
    next
    #由于一个被试不能正确计算贝叶斯因子，所以当i等于1时，跳过
  }
  #将df数据框中的subj_idx列转换为字符串型
  df_motion_diff_match$subj_idx <- as.character(df_motion_diff_match$subj_idx)
  #提取出遍历到的被试编号
  id <- unique(df_motion_diff_match$subj_idx)[1:i]
  #从原数据中筛选被试
  df.selected <- df_motion_diff_match %>% filter(subj_idx %in% id)
  #转换为因子型
  df.selected$subj_idx <- as.factor(df.selected$subj_idx)
  #计算贝叶斯因子
  bayesfactors <- ttestBF(df.selected$rt_diff_so_1,
                          df.selected$rt_diff_so_4, 
                          paired = TRUE, 
                          nullInterval = c(0, Inf))
  bf_output[i] <- bayesfactors[2]
}

aov_output <- tibble::tibble(bf_output)#整合为数据框
head(aov_output, 20)#查看数据
```

结果

可视化

```{r}
tibble(bf_output) %>% 
  dplyr::mutate(n = 1:nrow(.)) %>% 
  dplyr::rename("BayesFactor" = "bf_output") %>% 
  # dplyr::mutate(logBF = log(`Bayes Factor`)) %>% 
   ggplot(aes(x = n, y = `BayesFactor`)) + 
  geom_point(size = 3) + 
  geom_line() + 
  geom_hline(aes(yintercept = log(1)), linetype = "dashed") + 
  geom_hline(aes(yintercept = log(10)), linetype = "dashed") +
  labs(y = TeX("$\\BF_{10} $")) + 
  ggtitle("(self - other)easiest vs. (self - other)hardest Match_RT") + 
   theme(
    panel.background = element_blank(),
    plot.margin = unit(c(1, 1, 1, 1), "cm"),
    plot.background = element_rect(fill = "white", color = NA),
    plot.title = element_text(size = 22, face = "bold",
                              hjust = 0.5,
                              margin = margin(b = 15)),
    axis.line = element_line(color = "black", size = .5),
    axis.title = element_text(size = 18, color = "black",
                              face = "bold"),
    axis.text = element_text(size = 15, color = "black"),
    axis.text.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.ticks = element_line(size = .5),
    panel.grid = element_blank(),
    legend.position = c(0.20, 0.8),
    legend.background = element_rect(color = "black"),
    legend.text = element_text(size = 15),
    legend.margin = margin(t = 5, l = 5, r = 5, b = 5),
    legend.key = element_rect(color = NA, fill = NA))
```

## 辨别任务
### 重复测量方差分析
#### ACC


检验交互项

生成三个向量用来储存两个主效应和交互项
```{r}
BFs_difficulty <- rep(1, length(subj_num))

BFs_association <- rep(1, length(subj_num))

BFs_int <- rep(1, length(subj_num))
```

```{r}
for (i in seq_along(subj_num)) {
  if (i == 1) {
    next
  }
  df_color_rdk$subj_idx <- as.character(df_color_rdk$subj_idx)
  id <- unique(df_color_rdk$subj_idx)[1:i]
  df.selected <- df_color_rdk %>% dplyr::filter(subj_idx %in% id)
  df.selected$subj_idx <- as.factor(df.selected$subj_idx)
  df.selected$difficulty <- as.factor(df.selected$difficulty)
  df.selected$association <- as.factor(df.selected$association)
  bayesfactors <- BayesFactor::anovaBF(
    acc ~ difficulty * association + subj_idx,
    data = data.frame(df.selected), 
    whichRandom = "subj_idx",
    # neverExclude = "subj_idx", 
    # whichModels = "all",
    rscaleFixed = 0.5,
    progress = FALSE)
  print(bayesfactors)
  
  # 计算association主效应的BF
  BFs_association[i] <- bayesfactors[3]/bayesfactors[2] 
  # 计算difficulty的BF
  BFs_difficulty[i] <- bayesfactors[3]/bayesfactors[1] 
  # 计算交互项的BF
  BFs_int[i] <- bayesfactors[4]/bayesfactors[3] 
}

aov_output <- tibble::tibble(BFs_int, BFs_association, BFs_difficulty)#整合为数据框
head(aov_output, 20)#查看数据
```


```{r}
dat_plot <- aov_output %>% dplyr::mutate(n = 1:nrow(.)) %>% 
  tidyr::pivot_longer(BFs_int:BFs_difficulty, names_to = "Effect", 
               values_to = "Bayes_Factor") %>% 
  # dplyr::mutate(`logBF` = log(`Bayes Factor`)) %>% 
  dplyr::mutate(dplyr::across(where(is.double), 
                              ~round(.x, digits = 2)))
head(dat_plot, 20)
```


```{r}
dat_plot %>% dplyr::filter(Effect == "BFs_int") %>% 
  ggplot(aes(x = n, y = Bayes_Factor)) + 
  geom_point(size = 3) + 
  geom_line() + 
  geom_hline(aes(yintercept = log(1)), linetype = "dashed")+
  geom_hline(aes(yintercept = log(10)), linetype = "dashed")+
  labs(y = TeX("$\\BF_{10} $")) + 
  ggtitle("交互作用的贝叶斯因子数值变化趋势 RDK_ACC") + 
  # scale_y_continuous(
    # ) + 
   theme(
    panel.background = element_blank(),
    plot.margin = unit(c(1, 1, 1, 1), "cm"),
    plot.background = element_rect(fill = "white", color = NA),
    plot.title = element_text(size = 22, 
                              # family = "song",
                              face = "bold",
                              hjust = 0.5,
                              margin = margin(b = 15)),
    axis.line = element_line(color = "black", size = .5),
    axis.title = element_text(size = 18, color = "black",
                              face = "bold"),
    axis.text = element_text(size = 15, color = "black"),
    axis.text.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.ticks = element_line(size = 1),
    panel.grid = element_blank(),
    legend.position = c(0.20, 0.8),
    legend.background = element_rect(color = "black"),
    legend.text = element_text(size = 15),
    legend.margin = margin(t = 5, l = 5, r = 5, b = 5),
    legend.key = element_rect(color = NA, fill = NA))
```

####  RT

```{r}
set.seed(1234)
for (i in seq_along(subj_num)) {
  if (i == 1) {
    next
  }
  df_color_rdk$subj_idx <- as.character(df_color_rdk$subj_idx)
  id <- unique(df_color_rdk$subj_idx)[1:i]
  df.selected <- df_color_rdk %>% dplyr::filter(subj_idx %in% id)
  df.selected$subj_idx <- as.factor(df.selected$subj_idx)
  df.selected$difficulty <- as.factor(df.selected$difficulty)
  df.selected$association <- as.factor(df.selected$association)
  bayesfactors <- BayesFactor::anovaBF(
    rt ~ difficulty * association + subj_idx,
    data = data.frame(df.selected), 
    whichRandom = "subj_idx",
    # neverExclude = "subj_idx", 
    # whichModels = "all",
    rscaleFixed = 0.5,
    progress = FALSE)
  print(bayesfactors)
  
  # 计算association主效应的BF
  BFs_association[i] <- bayesfactors[3]/bayesfactors[2] 
  # 计算difficulty的BF
  BFs_difficulty[i] <- bayesfactors[3]/bayesfactors[1] 
  # 计算交互项的BF
  BFs_int[i] <- bayesfactors[4]/bayesfactors[3] 
}

aov_output <- tibble::tibble(BFs_int, BFs_association, BFs_difficulty)#整合为数据框
head(aov_output, 20)#查看数据
```


```{r}
plot_rt <- aov_output %>% dplyr::mutate(n = 1:nrow(.)) %>% 
  tidyr::pivot_longer(BFs_int:BFs_difficulty, names_to = "Effect", 
               values_to = "Bayes_Factor") %>% 
  # dplyr::mutate(`logBF` = log(`Bayes Factor`)) %>% 
  dplyr::mutate(dplyr::across(where(is.double), 
                              ~round(.x, digits = 2)))
head(dat_plot, 20)
```

```{r}
plot_rt %>% dplyr::filter(Effect == "BFs_int") %>% 
  ggplot(aes(x = n, y = Bayes_Factor)) + 
  geom_point(size = 3) + 
  geom_line() + 
  geom_hline(aes(yintercept = log(1)), linetype = "dashed")+
  geom_hline(aes(yintercept = log(10)), linetype = "dashed")+
  labs(y = TeX("$\\BF_{10} $")) + 
  ggtitle("交互作用的贝叶斯因子数值变化趋势 RDK_RT") + 
  # scale_y_continuous(
    # ) + 
   theme(
    panel.background = element_blank(),
    plot.margin = unit(c(1, 1, 1, 1), "cm"),
    plot.background = element_rect(fill = "white", color = NA),
    plot.title = element_text(size = 22, 
                              # family = "song",
                              face = "bold",
                              hjust = 0.5,
                              margin = margin(b = 15)),
    axis.line = element_line(color = "black", size = .5),
    axis.title = element_text(size = 18, color = "black",
                              face = "bold"),
    axis.text = element_text(size = 15, color = "black"),
    axis.text.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.ticks = element_line(size = .5),
    panel.grid = element_blank(),
    legend.position = c(0.20, 0.8),
    legend.background = element_rect(color = "black"),
    legend.text = element_text(size = 15),
    legend.margin = margin(t = 5, l = 5, r = 5, b = 5),
    legend.key = element_rect(color = NA, fill = NA))
# ggsave("RT_inx.png", width = 10, height = 7, dpi = 300)
```

### 配对样本T检验
假设：(self - other)hard 条件优于 (self - other)easy 条件

#### ACC

先建立一个空的列表，用来储存后续的贝叶斯因子。列表长度为目前数据的样本量

```{r}
bf_output <- rep(1, length(subj_num)) ### 先建立一个列表
```

```{r message=FALSE}
for (i in seq_along(subj_num)) {#i遍历subj_num
  if (i == 1) {
    next
    #由于一个被试不能正确计算贝叶斯因子，所以当i等于1时，跳过
  }
  #将df数据框中的subj_idx列转换为字符串型
  df_motion_diff_rdk$subj_idx <- as.character(df_motion_diff_rdk$subj_idx)
  #提取出遍历到的被试编号
  id <- unique(df_motion_diff_rdk$subj_idx)[1:i]
  #从原数据中筛选被试
  df.selected <- df_motion_diff_rdk %>% filter(subj_idx %in% id)
  #转换为因子型
  df.selected$subj_idx <- as.factor(df.selected$subj_idx)
  #计算贝叶斯因子
  bayesfactors <- ttestBF(df.selected$acc_diff_so_1,
                          df.selected$acc_diff_so_4, 
                          paired = TRUE, 
                          nullInterval = c(0, Inf))
  bf_output[i] <- bayesfactors[2]
}

aov_output <- tibble::tibble(bf_output)#整合为数据框
head(aov_output, 20)#查看数据
```


结果

```{r}
tibble(bf_output) %>% 
  dplyr::mutate(n = 1:nrow(.)) %>% 
  dplyr::rename("BayesFactor" = "bf_output") %>% 
  # dplyr::mutate(logBF = log(`Bayes Factor`)) %>% 
   ggplot(aes(x = n, y = `BayesFactor`)) + 
  geom_point(size = 3) + 
  geom_line() + 
  geom_hline(aes(yintercept = log(1)), linetype = "dashed") + 
  geom_hline(aes(yintercept = log(10)), linetype = "dashed") +
  labs(y = TeX("$\\BF_{10} $")) + 
  ggtitle("(self - other)easiest vs. (self - other)hardest RDK_ACC") + 
   theme(
    panel.background = element_blank(),
    plot.margin = unit(c(1, 1, 1, 1), "cm"),
    plot.background = element_rect(fill = "white", color = NA),
    plot.title = element_text(size = 22, face = "bold",
                              hjust = 0.5,
                              margin = margin(b = 15)),
    axis.line = element_line(color = "black", size = .5),
    axis.title = element_text(size = 18, color = "black",
                              face = "bold"),
    axis.text = element_text(size = 15, color = "black"),
    axis.text.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.ticks = element_line(size = .5),
    panel.grid = element_blank(),
    legend.position = c(0.20, 0.8),
    legend.background = element_rect(color = "black"),
    legend.text = element_text(size = 15),
    legend.margin = margin(t = 5, l = 5, r = 5, b = 5),
    legend.key = element_rect(color = NA, fill = NA))
```


#### RT

```{r message=FALSE}
for (i in seq_along(subj_num)) {#i遍历subj_num
  if (i == 1) {
    next
    #由于一个被试不能正确计算贝叶斯因子，所以当i等于1时，跳过
  }
  #将df数据框中的subj_idx列转换为字符串型
  df_motion_diff_rdk$subj_idx <- as.character(df_motion_diff_rdk$subj_idx)
  #提取出遍历到的被试编号
  id <- unique(df_motion_diff_rdk$subj_idx)[1:i]
  #从原数据中筛选被试
  df.selected <- df_motion_diff_rdk %>% filter(subj_idx %in% id)
  #转换为因子型
  df.selected$subj_idx <- as.factor(df.selected$subj_idx)
  #计算贝叶斯因子
  bayesfactors <- ttestBF(df.selected$rt_diff_so_1,
                          df.selected$rt_diff_so_4, 
                          paired = TRUE, 
                          nullInterval = c(0, Inf))
  bf_output[i] <- bayesfactors[2]
}

aov_output <- tibble::tibble(bf_output)#整合为数据框
head(aov_output, 20)#查看数据
```

结果

```{r}
aov_output <- tibble::tibble(bf_output)#整合为数据框
head(aov_output, 13)#查看数据
```

可视化

```{r}
tibble(bf_output) %>% 
  dplyr::mutate(n = 1:nrow(.)) %>% 
  dplyr::rename("BayesFactor" = "bf_output") %>% 
  # dplyr::mutate(logBF = log(`Bayes Factor`)) %>% 
   ggplot(aes(x = n, y = `BayesFactor`)) + 
  geom_point(size = 3) + 
  geom_line() + 
  geom_hline(aes(yintercept = log(1)), linetype = "dashed") + 
  geom_hline(aes(yintercept = log(10)), linetype = "dashed") +
  labs(y = TeX("$\\BF_{10} $")) + 
  ggtitle("(self - other)easiest vs. (self - other)hardest RT") + 
   theme(
    panel.background = element_blank(),
    plot.margin = unit(c(1, 1, 1, 1), "cm"),
    plot.background = element_rect(fill = "white", color = NA),
    plot.title = element_text(size = 22, face = "bold",
                              hjust = 0.5,
                              margin = margin(b = 15)),
    axis.line = element_line(color = "black", size = .5),
    axis.title = element_text(size = 18, color = "black",
                              face = "bold"),
    axis.text = element_text(size = 15, color = "black"),
    axis.text.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.ticks = element_line(size = .5),
    panel.grid = element_blank(),
    legend.position = c(0.20, 0.8),
    legend.background = element_rect(color = "black"),
    legend.text = element_text(size = 15),
    legend.margin = margin(t = 5, l = 5, r = 5, b = 5),
    legend.key = element_rect(color = NA, fill = NA))
```