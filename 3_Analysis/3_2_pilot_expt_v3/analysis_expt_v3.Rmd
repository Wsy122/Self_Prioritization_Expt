---
title: "R Notebook"
output: html_notebook
---

# 加载定义函数

```{r setup, include=FALSE}
source("../3_1_pilot_expt_1a/R_rainclouds.R")
```

# 读取目录下数据 pilot_expt_v3

```{r}
# 设置目标文件夹相对路径
folder_path <- "../../2_Experiments/2_1_Pilot_Experiment/2_1_2_RawData/pilot_expt_v3"

# 列出所有含有"Exp1A_"的csv文件
file_list <- list.files(
  path = folder_path,
  pattern = "*pilot_expt_v3_.*\\.csv$", full.names = TRUE
)

# 创建一个空列表来存储数据
df_list_1 <- list()

# 逐个读取文件并存储
for (file in file_list) {
  file_name <- tools::file_path_sans_ext(basename(file))  # 获取文件名（不带扩展名）
  df_list_1[[file_name]] <- read.csv(file)  # 将数据存储在列表中
}
#rm(file, file_list, folder_path)
```

# 数据清洗 pilot_expt_v3

```{r}
# 创建输出文件夹（如果不存在）
output_path <- "../../2_Experiments/2_1_Pilot_Experiment/2_1_3_CleanData/pilot_expt_v3"
if (!dir.exists(output_path)) {
  dir.create(output_path, recursive = TRUE)
}

# 逐篇处理每个数据框
for (file_name in names(df_list_1)) {
  data <- df_list_1[[file_name]]

  # 提取被试信息
  participant_info <- data[data$part == "survey", "response"]
  participant_info <- gsub("[{}\"]", "", participant_info) # 去掉多余的字符
  info_list <- strsplit(participant_info, ",")[[1]]

  # 创建新的变量
  participant_data <- data.frame(
    Participant_ID = file_name,
    Sex = as.character(NA),
    Age = as.numeric(NA),
    Handedness = as.character(NA),
    #Color_blindness = as.character(NA),
    stringsAsFactors = FALSE
  )
  
  # 先按照下划线分割字符串
  split_data <- strsplit(participant_data$Participant_ID, "_")
  # 提取分割后的第四个元素（数字部分在第四个位置，可根据实际调整）并转换为数值
  participant_data$Participant_ID <- as.numeric(lapply(split_data, function(x) substr(x[[4]], 1, 2)))

  for (info in info_list) {
    key_value <- strsplit(info, ":")[[1]]
    key <- trimws(key_value[1])
    value <- trimws(key_value[2])
    if (key == "sex") participant_data$Sex <- value
    if (key == "age") participant_data$Age <- as.numeric(value)
    if (key == "hands") participant_data$Handedness <- value
    #if (key == "color_blindness") participant_data$Color_blindness <- value
  }

  # 提取行为数据
  behavior_data <- data[
    data$part %in% c("color_pract", "color_formal", "motion_pract", "motion_formal"),
    c(
      "part", "rt", "response", "correct", "coherent_direction",
      "coherence", "target_color_proportion", "dot_color_final",
      "coherent_direction"
    )
  ]
  # 将 correct 列转换为逻辑型
  behavior_data$correct <- as.logical(behavior_data$correct)

  # 然后再转换为 0 和 1
  behavior_data$correct <- as.integer(behavior_data$correct)

  # 分别提取正式试次
  official_trials <- do.call(
    rbind,
    lapply(unique(behavior_data$part), function(part) {
      part_data <- behavior_data[behavior_data$part == part, ]
      #tail(part_data, 120) # 取最后120个试次
    })
  )

  # 合并被试信息和行为数据
  final_data <- cbind(participant_data, official_trials
                      )

  # 输出到新的CSV文件
  output_file <- file.path(output_path, paste0(file_name, "_Clean.csv"))
  write.csv(final_data, output_file, row.names = FALSE)
}
```

# 读取清洗后的数据 pilot_expt_v3

```{r}
# 设置目标文件夹相对路径
folder_path <- "../../2_Experiments/2_1_Pilot_Experiment/2_1_3_CleanData/pilot_expt_v3"

# 列出所有含有"Exp1A_"的csv文件
file_list <- list.files(
  path = folder_path,
  pattern = "*pilot_expt_v3_.*\\.csv$", full.names = TRUE
)

# 创建一个空列表来存储数据
df_list_1 <- list()

# 逐个读取文件并存储
for (file in file_list) {
  file_name <- tools::file_path_sans_ext(basename(file)) # 获取文件名（不带扩展名）
  df_list_1[[file_name]] <- read.csv(file) # 将数据存储在列表中
}

rm(output_path, participant_info, info_list, participant_data, split_data,
   behavior_data, official_trials, final_data, output_file, file, file_list,
   file_name, folder_path, info, key, key_value, packages, value)
```

---
## 分析思路
1. 绘制反应曲线（x轴为相干性，y轴为正确率）
2. 对不同条件下的正确率和反应时进行重复测量方差分析
  - 判断类型：颜色 vs. 运动
  - 难度类型：容易 vs. 困难（part1 vs. part2）
3. 对正确率采用信号检测论的方法（有时间就做）
  - 颜色判断：红为信号，蓝为噪声
  - 运动方向判断：左为信号，右为噪声
---


# 加载所需要的包

```{r}
library(ggplot2)
library(dplyr)
#library(ggokabeito)
library(cowplot)
library(bruceR)
library(emmeans)
library(ggstatsplot) 
library(palmerpenguins)
library(tidyverse)
library(patchwork)
library(RColorBrewer)
```

# 准备数据

```{r}

# 把 df_list_1 传送给 data
data <- do.call(rbind, df_list_1)

# 选择实验组

data_all <- data %>%
  filter(
    #Participant_ID %in% c( seq(1, 25)),
    rt >= 200 & rt <= 3000) %>% #筛出反应时在200~3000)
    group_by(Participant_ID) %>%
    mutate(
      step = ifelse(grepl("_pract", part), "pract", "formal"),
      judge_type = ifelse(grepl("color_", part), "color", "motion")
    ) %>%
    group_by(Participant_ID, judge_type, step) %>%
    mutate(
      difficulty = case_when(
        step == "pract" & row_number() <= 50 ~ "easy_pract",
        step == "pract" & row_number() > 50  ~ "hard_pract",
        step == "formal" & row_number() <= 240 ~ "easy_formal",
        step == "formal" & row_number() > 240 ~ "hard_formal",
        TRUE ~ "other"
      )
    ) %>%
  ungroup()
```

```{r}
# 新数据，需要包含被试编号、试次编号和相干性比例

df_new <- data_all %>% 
  filter(step == "formal")  %>%
  group_by(Participant_ID, judge_type, difficulty) %>%
  mutate(trial_num = row_number()) 

df_new <- df_new[, c("Participant_ID", "judge_type", "difficulty", "coherence",
                     "target_color_proportion", "trial_num")]
# 保存为CSV文件到目标文件夹
write.table(df_new, file = "../3_2_pilot_expt_v3/output/df_new.csv", row.names = FALSE)
```

```{r}
#计算平均正确率和反应时
#运动和颜色分开计算

df_motion <- data_all %>% #运动
  filter(step == "formal" & judge_type == "motion") %>%
    group_by(Participant_ID, part, difficulty, coherence) %>%  #进行分组
    summarise(
      avg_rt = mean(rt, na.rm = TRUE),#每个被试所有trial的平均反应时
      max_rt = max(rt, na.rm = TRUE),#每个被试所有trial的最大反应时
      min_rt = min(rt, na.rm = TRUE),#每个被试所有trial的最小反应时
      sd_rt = sd(rt, na.rm = TRUE), #每个被试所有trial的反应时的方差
      all_count = n(),#每个被试在每个条件的总trial数量
      row_count = sum(rt >= 200 & rt <= 3000, na.rm = TRUE), #舍弃按键太快和按键太慢的反应时
      correct_count = sum(correct == 1 & rt >= 200 & rt <= 3000, na.rm = TRUE),
      acc = correct_count /row_count,
      .groups = "drop")

# 剔除 df_motion 中正确率的极值
mean_acc_motion <- mean(df_motion$acc, na.rm = TRUE)
sd_acc_motion <- sd(df_motion$acc, na.rm = TRUE)
lower_bound_motion <- mean_acc_motion - 3 * sd_acc_motion
upper_bound_motion <- mean_acc_motion + 3 * sd_acc_motion
# [ , ] 逗号前为行，后为列
df_motion <- df_motion[df_motion$acc >= lower_bound_motion & df_motion$acc <= upper_bound_motion, ]

df_color <- data_all %>% #颜色
  filter(step == "formal" & judge_type == "color") %>%
    group_by(Participant_ID, part, difficulty, target_color_proportion) %>%  #进行分组
    summarise(
      avg_rt = mean(rt, na.rm = TRUE),#每个被试所有trial的平均反应时
      max_rt = max(rt, na.rm = TRUE),#每个被试所有trial的最大反应时
      min_rt = min(rt, na.rm = TRUE),#每个被试所有trial的最小反应时
      sd_rt = sd(rt, na.rm = TRUE), #每个被试所有trial的反应时的方差
      all_count = n(),#每个被试在每个条件的总trial数量
      row_count = sum(rt >= 200 & rt <= 3000&target_color_proportion < 0.8,
                      na.rm = TRUE), #舍弃按键太快和按键太慢的反应时
      correct_count = sum(correct == 1 & rt >= 200 & rt <= 3000 & target_color_proportion < 0.8,
                          na.rm = TRUE),
      acc = correct_count /row_count,
      .groups = "drop")

df_color2 <- data_all %>% #颜色
  filter(step == "formal" & judge_type == "color") %>%
    mutate(
      dot_color_final = case_when(
      dot_color_final == '["hsl(0, 50%, 50%)","hsl(225, 50%, 50%)"]' ~ "red",
      dot_color_final == '["hsl(225, 50%, 50%)","hsl(0, 50%, 50%)"]' ~ "blue",
      TRUE ~ "other"
    )
  ) %>% #进行分组
    group_by(Participant_ID, part, difficulty, target_color_proportion, dot_color_final) %>%
    summarise(
      avg_rt = mean(rt, na.rm = TRUE),#每个被试所有trial的平均反应时
      max_rt = max(rt, na.rm = TRUE),#每个被试所有trial的最大反应时
      min_rt = min(rt, na.rm = TRUE),#每个被试所有trial的最小反应时
      sd_rt = sd(rt, na.rm = TRUE), #每个被试所有trial的反应时的方差
      all_count = n(),#每个被试在每个条件的总trial数量
      row_count = sum(rt >= 200 & rt <= 3000&target_color_proportion < 0.8,
                      na.rm = TRUE), #舍弃按键太快和按键太慢的反应时
      correct_count = sum(correct == 1 & rt >= 200 & rt <= 3000 & target_color_proportion < 0.8,
                          na.rm = TRUE),
      acc = correct_count /row_count,
      .groups = "drop") 


# 剔除 df_color 中正确率的极值
mean_acc_color <- mean(df_color$acc, na.rm = TRUE)
sd_acc_color <- sd(df_color$acc, na.rm = TRUE)
lower_bound_color <- mean_acc_color - 3 * sd_acc_color
upper_bound_color <- mean_acc_color + 3 * sd_acc_color
df_color <- df_color[df_color$acc >= lower_bound_color & df_color$acc <= upper_bound_color, ]

mean_acc_color2 <- mean(df_color2$acc, na.rm = TRUE)
sd_acc_color2 <- sd(df_color2$acc, na.rm = TRUE)
lower_bound_color2 <- mean_acc_color2 - 3 * sd_acc_color2
upper_bound_color2 <- mean_acc_color2 + 3 * sd_acc_color2
df_color2 <- df_color2[df_color2$acc >= lower_bound_color2 & df_color2$acc <= upper_bound_color2, ]

# 去除 df_color 中的缺失值
df_color <- na.omit(df_color)
df_color2 <- na.omit(df_color2)
# 去除 df_motion 中的缺失值
df_motion <- na.omit(df_motion)

# 将被试 ID 列转换为因子类型
df_color$subject_id <- factor(df_color$Participant_ID)
df_motion$subject_id <- factor(df_motion$Participant_ID)

df_all <- bind_rows(df_motion, df_color)

# 保存为CSV文件到目标文件夹
write.table(df_all, file = "../3_2_pilot_expt_v3/output/df_all.csv", row.names = FALSE)
write.table(df_motion, file = "../3_2_pilot_expt_v3/output/df_motion.csv", row.names = FALSE)
write.table(df_color, file = "../3_2_pilot_expt_v3/output/df_color.csv", row.names = FALSE)
write.table(df_color2, file = "../3_2_pilot_expt_v3/output/df_color2.csv", row.names = FALSE)
```


```{r}
op <- par(mfrow = c(1, 2), mar=c(3.2,3.2,2,.5), mgp=c(2,.7,0)) #make two plots in two columns 
plot( acc ~ coherence, data = df_motion, main="motion")
plot( acc ~ target_color_proportion, data = df_color, main="color")
#plot(acc ~ log(coherence), data = df_motion, main="Logarithmic Scale")
```

## 查看数据分布

```{r}
# 导入所需要的包
library(ggpubr)

# 创建四个图形对象
p1 <- ggscatterhist(
  df_motion, x = "coherence", y = "acc", color = "subject_id", size = 2, alpha = 0.7,
  margin.params = list(fill = "subject_id", color = "black", size = 0.2),
  margin.plot =  "histogram",
  legend = "top",
  ggtheme = theme_pubr()
) 

p2 <- ggscatterhist(
  df_motion, x = "coherence", y = "avg_rt", color = "subject_id", size = 2, alpha = 0.7,
  margin.params = list(fill = "subject_id", color = "black", size = 0.2, alpha = 1),
  margin.plot =  "histogram",
  legend = "top",
  ggtheme = theme_pubr()
) 

p3 <- ggscatterhist(
  df_color, x = "target_color_proportion", y = "acc", color = "subject_id", size = 2, alpha = 0.7,
  margin.params = list(fill = "subject_id", color = "black", size = 0.2, alpha = 1),
  margin.plot =  "histogram",
  legend = "top",
  ggtheme = theme_pubr()
)

p4 <- ggscatterhist(
  df_color, x = "target_color_proportion", y = "avg_rt", color = "subject_id", size = 2, alpha = 0.7,
  margin.params = list(fill = "subject_id", color = "black", size = 0.2, alpha = 1),
  margin.plot =  "histogram",
  legend = "top",
  ggtheme = theme_pubr()
)

```







----------------------------分割线----------------------------------------------------------------------
# 雨云图 + 方差分析
## matching task

```{r}
colors <- c("lightblue", "orange", "grey", "green")

matching_task_analysis <- function(data){
  
  # 获取数据名
  data_name <- deparse(substitute(data))
  # 从数据名中区分不同的组别
  split_result <- strsplit(data_name, "_")[[1]]
  group <- split_result[2]
  
  # 计算所需要的画图数据1 (此为长数据)
  matching_task_data <- data %>% #选择正式实验的数据
    filter(part == "match_RDK") %>%
    group_by(Participant_ID, match, association) %>%  #按被试与匹配条件分组
    summarise(
      avg_rt = mean(rt, na.rm = TRUE),#每个被试所有trial的平均反应时
      max_rt = max(rt, na.rm = TRUE),#每个被试所有trial的最大反应时
      min_rt = min(rt, na.rm = TRUE),#每个被试所有trial的最小反应时
      sd_rt = sd(rt, na.rm = TRUE), #每个被试所有trial的反应时的方差
      all_count = n(),#每个被试在每个条件的总trial数量
      row_count = sum(rt >= 200 & rt <= 3000, na.rm = TRUE), #舍弃按键太快和按键太慢的反应时
      correct_count = sum(correct == 1 & rt >= 200 & rt <= 3000, na.rm = TRUE),
      acc = correct_count /all_count,
      .groups = "drop") %>% #计算每个被试在每个条件的正确率= 正确/总数
      mutate(match = case_when(
      match == "yes" ~ "match",
      match == "no"~ "nonmatch",
      )) %>% # 更改错误
        mutate(association = case_when(
          match == "nonmatch" & association == "self" ~ "other",
          match == "nonmatch" & association == "other" ~ "self",
          match == "match" & association == "self" ~ "self",
          match == "match" & association == "other" ~ "other",
      ))
  
  # 加一列新的变量
  matching_task_data <- matching_task_data %>% 
    mutate(conditions = case_when(
      association == "self" & match == "match" ~ "selfMatch",
      association == "self" & match == "nonmatch" ~ "selfNonmatch",
      association == "other" & match == "match" ~ "otherMatch",
      association == "other" & match == "nonmatch" ~ "otherNonmatch"))
  
   # 把不同的条件重新排一下序
   matching_task_data$conditions <- factor(matching_task_data$conditions,
                                 levels=c("selfMatch","otherMatch","selfNonmatch","otherNonmatch"))
   
   print(matching_task_data)

  # ACC plot (match condition)
  acc_plot <- ggplot(
    matching_task_data,
    aes(x = conditions, y = acc, fill = association, colour = association)) +
    geom_flat_violin(
      position = position_nudge(x = .2, y = 0), adjust = 1.2, trim = FALSE, alpha = 0.8) +
    geom_jitter(aes(x = conditions, y = acc, color= association), width = 0.15) +
    # geom_point(position = position_jitter(width = .15), size = .25, alpha = 0.5) +
    geom_boxplot(
      aes(x = conditions, y = acc), outlier.shape = NA, alpha = 0.7, width = .1, colour = "BLACK") +
    ylab("ACC") + xlab(' ') + coord_flip() +
    theme_cowplot() + guides(fill = "none", colour = "none") +
    scale_colour_manual(values = colors) + #palette = "Dark2"
    scale_fill_manual(values = colors) + #palette = "Dark2"
    ggtitle(" ") +
    theme(plot.title = element_text(hjust = -0.4 , vjust = 2 ))

 # RT plot (match condition)
  rt_plot <- ggplot(
    matching_task_data,
    aes(x = conditions, y = avg_rt, fill = association, colour = association)) +
    geom_flat_violin(
      position = position_nudge(x = .2, y = 0), adjust = 1.2, trim = FALSE, alpha = 0.8) +
    geom_jitter(aes(color= association), width = 0.1) +
    # geom_point(position = position_jitter(width = .15), size = .25, alpha = 0.5) +
    geom_boxplot(
      aes(x = conditions, y = avg_rt), outlier.shape = NA, alpha = 0.7, width = .1, colour = "BLACK") +
    ylab("RT (ms)") + xlab(' ') + coord_flip() +
    theme_cowplot() + #guides(fill = association, colour = association) +
    scale_colour_manual(values = colors) + #palette = "Dark2"
    scale_fill_manual(values = colors) #palette = "Dark2"
    # ggtitle("Figure b: RT of Matching Task")

  # Combine plots vertically
  # final_plot <- plot_grid(acc_plot, rt_plot, ncol = 1)  # ncol = 1 表示垂直排列，组合两个图形
  # ggsave(output_file, final_plot, width = 10, height = 15) # 输出保存到文件夹
  #print(final_plot)
  # ggsave("fig2_matching_task.png", final_plot, width = 10, height = 8, dpi = 300)
  
  

  
  
  # 合并四个图形
  #combined_plot <- plot_grid(
    #acc_plot, rt_plot,
    #acc_plot2, rt_plot2,
    #align = "hv", ncol = 2,
    #labels = c("No overlapping", " ", "Overlapping")
    #) 
  plot_title <- paste0(group, " ", "group")
  combined_plot <- acc_plot + rt_plot +
    plot_annotation(title = plot_title,
                    theme = theme(plot.title = element_text(size = 30, hjust = 0.5))) 
  
  print(combined_plot)
  
  #输出保存到文件夹
  output_file_name <- paste0("matching_task_", group, ".png")
  target_folder_path <- "../3_1_Expt_1a/output"
ggsave(file.path(target_folder_path, output_file_name), combined_plot, width = 10, height = 8, dpi = 300)
  
  # 计算新的数据（包括所有被试的平均正确率和平均反应时）
  matching_task_data2 <- data %>%
    filter(part == "match_RDK") %>%
    group_by(Participant_ID, match, association) %>%  # 按被试与条件分组
    summarise(
      avg_rt = mean(rt, na.rm = TRUE), sd_rt=sd(rt, na.rm = TRUE),
      max_rt = max(rt, na.rm = TRUE), min_rt = min(rt, na.rm = TRUE),
      all_count=n(), row_count = sum(rt>=200 & rt <= 3000, na.rm = TRUE),
      correct_count = sum(correct == 1 & rt >= 200 & rt <= 3000, na.rm = TRUE),
      acc = correct_count /all_count,
      .groups = "drop"
      )
  
  # **自我/他人 x 匹配/不匹配的反应时和正确率的方差分析**
  acc_file_name <- paste0("matching_task_ACC_", deparse(substitute(data)), ".doc")
  matching_task_ACC <- matching_task_data2 %>% 
    MANOVA(., dv = "acc", subID= "Participant_ID",
           within = c("match", "association"),
           sph.correction = "GG",
           file = file.path(target_folder_path, acc_file_name)
           ) %>%
    emmeans("match", by = "association")
   
  rt_file_name <- paste0("matching_task_RT_", deparse(substitute(data)), ".doc") 
  matching_task_RT <- matching_task_data2 %>%
    MANOVA(., dv = "avg_rt", subID="Participant_ID",
           within = c("match", "association"),
           sph.correction="GG",
           file = file.path(target_folder_path, rt_file_name)
           ) %>%
    emmeans("match", by = "association")

}

matching_task_analysis(data_motion)
matching_task_analysis(data_color_all)
```


# 雨云图 + 方差分析
## RDK task

```{r}
colors <- c("lightblue", "orange", "grey", "green")

matching_task_analysis2 <- function(data){
  
  # 获取数据名
  data_name <- deparse(substitute(data))
  # 从数据名中区分不同的组别
  split_result <- strsplit(data_name, "_")[[1]]
  group <- split_result[2]
  
  target_folder_path <- "../3_1_Expt_1a/output"
  
  # 计算所需要的画图数据1
  matching_task_data <- data %>% #选择正式实验的数据
    filter(part == "RDK") %>%
    group_by(Participant_ID, association, difficulty) %>%  #按被试与匹配条件分组
    summarise(
      avg_rt = mean(rt, na.rm = TRUE),#每个被试所有trial的平均反应时
      max_rt = max(rt, na.rm = TRUE),#每个被试所有trial的最大反应时
      min_rt = min(rt, na.rm = TRUE),#每个被试所有trial的最小反应时
      sd_rt = sd(rt, na.rm = TRUE), #每个被试所有trial的反应时的方差
      all_count = n(),#每个被试在每个条件的总trial数量
      row_count = sum(rt>=200 & rt <= 3000, na.rm = TRUE), #舍弃按键太快和按键太慢的反应时
      correct_count = sum(correct == 1 & rt>=200 & rt <= 3000, na.rm = TRUE),
      acc = correct_count /all_count,
      .groups = "drop") #计算每个被试在每个条件的正确率= 正确/总数
      
  
  # 加一列新的变量
  matching_task_data <- matching_task_data %>% 
    mutate(conditions = case_when(
      association == "self" & difficulty == "easy" ~ "selfEasy",
      association == "self" & difficulty == "difficult" ~ "selfHard",
      association == "other" & difficulty == "easy" ~ "otherEasy",
      association == "other" & difficulty == "difficult" ~ "otherHard"))
  
   # 把不同的条件重新排一下序
   matching_task_data$conditions <- factor(matching_task_data$conditions,
                                 levels=c("selfEasy","otherEasy","selfHard","otherHard"))

  # ACC plot (difficulty)
  acc_plot <- ggplot(
    matching_task_data,
    aes(x = conditions, y = acc, fill = association , colour = association)) +
    geom_flat_violin(
      position = position_nudge(x = .2, y = 0), adjust = 1.2, trim = FALSE, alpha = 0.5) +
    geom_jitter(aes(color= association), width = 0.15) +
    # geom_point(position = position_jitter(width = .15), size = .25, alpha = 0.5) +
    geom_boxplot(aes(x = conditions, y = acc), outlier.shape = NA, alpha = 0.5, width = .1, colour = "BLACK") +
    ylab('ACC') + xlab(' ') + coord_flip() +
    theme_cowplot() + guides(fill = "none", colour = "none") +
    scale_colour_manual(values = colors) + #palette = "Dark2"
    scale_fill_manual(values = colors) + #palette = "Dark2"
    ggtitle("RDP Task")

 # RT plot (difficulty)
  rt_plot <- ggplot(
    matching_task_data,
    aes(x = conditions, y = avg_rt, fill = association, colour = association)) +
    geom_flat_violin(
      position = position_nudge(x = .2, y = 0), adjust = 1.2, trim = FALSE, alpha = 0.5) +
    geom_jitter(aes(color = association), width = 0.15) +
    # geom_point(position = position_jitter(width = .15), size = .25, alpha = 0.5) +
    geom_boxplot(
      aes(
        x = conditions, y = avg_rt), outlier.shape = NA, alpha = 0.5, width = .1, colour = "BLACK") +
    ylab("RT (ms)") + xlab(' ') + coord_flip() +
    theme_cowplot() + #guides(fill = "none", colour = "none") +
    scale_colour_manual(values = colors) + #palette = "Dark2"
    scale_fill_manual(values = colors) #palette = "Dark2"
    # ggtitle("Figure b: RT of Matching Task")

  # Combine plots vertically
  # final_plot <- plot_grid(acc_plot, rt_plot, ncol = 1)  # ncol = 1 表示垂直排列，组合两个图形
  # ggsave(output_file, final_plot, width = 10, height = 15) # 输出保存到文件夹
  # print(final_plot)
  # ggsave("fig2_matching_task.png", final_plot, width = 10, height = 8, dpi = 300)
  
  
  # 合并四个图形
  plot_title <- paste0(group, " ", "group")
  combined_plot <- acc_plot + rt_plot +
    plot_annotation(title = plot_title,
                    theme = theme(plot.title = element_text(size = 30, hjust = 0.5))) 
  
  print(combined_plot)
  
  
  #输出保存到文件夹
  output_file_name <- paste0("rdk_task_", deparse(substitute(data)), ".png")
  ggsave(file = file.path(target_folder_path, output_file_name), combined_plot, width = 10, height = 8, dpi = 300)
  
  # 计算新的数据3（包括所有被试的平均正确率和平均反应时）
  matching_task_data3 <- data %>%
    filter(part == "RDK") %>%
    group_by(Participant_ID, difficulty, association) %>%  # 按被试与条件分组
    summarise(
      avg_rt = mean(rt, na.rm = TRUE), sd_rt=sd(rt, na.rm = TRUE),
      max_rt = max(rt, na.rm = TRUE), min_rt = min(rt, na.rm = TRUE),
      all_count=n(), row_count = sum(rt>=200 & rt <= 3000, na.rm = TRUE),
      correct_count = sum(correct == 1 & rt >= 200 & rt <= 3000, na.rm = TRUE),
      acc = correct_count /all_count,
      .groups = "drop"
      )
  
  # **自我/他人 x 匹配/不匹配的反应时和正确率的方差分析**
  acc_file_name <- paste0("rdk_task_ACC_", deparse(substitute(data)), ".doc")
  matching_task_ACC <- matching_task_data3 %>% 
    MANOVA(., dv = "acc", subID= "Participant_ID",
           within = c("difficulty", "association"),
           sph.correction = "GG",
           file = file.path(target_folder_path, acc_file_name)
           ) %>%
    emmeans("difficulty", by = "association")
   
  rt_file_name <- paste0("rdk_task_RT_", deparse(substitute(data)), ".doc") 
  matching_task_RT <- matching_task_data3 %>%
    MANOVA(., dv = "avg_rt", subID="Participant_ID",
           within = c("difficulty", "association"),
           sph.correction="GG",
           file = file.path(target_folder_path, rt_file_name)
           ) %>%
    emmeans("difficulty", by = "association")

}

# 调用函数
matching_task_analysis2(data_motion)
matching_task_analysis2(data_color_secd)
```


# 信号检测论分析
## matching task

```{r 正确率和dprime}

analysis_dprime_matching <- function(data) {
  
  # 设置保存文件的路径
  target_folder_path <- "../3_1_Expt_1a/output"
   
  sdt <- data %>% #选择正式实验的数据
  filter(part == "match_RDK") %>%
  group_by(Participant_ID, association) %>%  #按被试与条件分组
  dplyr::mutate(
    type = dplyr::case_when(
      (response == "f" & match == "yes") ~ "hit",
      (response == "j" & match == "no") ~ "cr",
      (response == "j" & match == "yes") ~ "miss",
      (response == "f" & match == "no") ~ "fa")) %>%
     summarize(
       hit = sum(type == "hit"),
       miss = sum(type == "miss"),
       fa = sum(type == "fa"),
       cr = sum(type == "cr"),
       .groups = "drop")
  sdt <- sdt %>%
     #replace_na(list(hit = 0, miss = 0, cr = 0, fa = 0)) %>%
     #mutate(zhr = qnorm(hit / (hit+miss)),
            #zfa = qnorm(fa / (fa+cr)),
            #dprime = zhr-zfa,
            #crit = -zfa)
    dplyr::mutate(hitR = hit/(hit + miss),  # hit rate
                  faR  = fa/(fa+cr)) %>%    # fa rate
    replace_na(list(hitR = 0, faR = 0)) %>%
                  # if hit rate is 1, standardize it
    dplyr::mutate(hitR = ifelse(hitR == 1, 1 - 1/(2*(hit + miss)), hitR), 
                  # if FA rate is 0, standardize it
                  faR  = ifelse(faR == 0, 1/(2*(hit + miss)), faR)) %>% 
    dplyr::mutate(dprime = qnorm(hitR) - qnorm(faR),
                  zfa = qnorm(fa / (fa+cr)),
                  crit = -zfa
                  ) %>%
    mutate( dprime = round(dprime, 2),
           crit = round(crit, 2)
           )
         
  

    # 把 sdt 设为环境变量
    assign("sdt", sdt, envir = .GlobalEnv)
    
    # 这里，我原来是想把 sdt 数据加入原数据中
    #sdt_data1 <- data %>%
      #right_join(sdt, by = "Participant_ID") %>%
      #group_by(Participant_ID, association, dprime) %>%
      #summarize(count = n()) 
    #print(sdt_data1)
    
    d_plot1 <- sdt %>%
    ggplot(., aes(x = association, y = dprime, fill = association, colour = association)) +
    geom_flat_violin(position = position_nudge(x = .2, y = 0), adjust = 2, trim = FALSE, alpha = 0.5) +
    geom_jitter(aes(color = association), width = 0.1) +
    #geom_point(position = position_jitter(width = .15), size = .25, alpha = 0.5) +
    geom_boxplot(aes(x = association, y = dprime), outlier.shape = NA, alpha = 0.5, width = .1, colour = "BLACK") +
    ylab('dprime') +  coord_flip() +
    theme_cowplot() + guides(fill = "none", colour = "none") +
    scale_colour_manual(values = colors) + # palette = "Dark2"
    scale_fill_manual(values = colors) # palette = "Dark2"
    #ggtitle("Figure 2a: ACC of ALT2_moral")+
    #guides(fill = guide_legend(title = "参照条件"), colour = guide_legend(title = "参照条件"))
    
    print(d_plot1)
    
    #sdt_data2 <- data %>%
      #filter(part == "match_RDK") %>%
      #right_join(sdt, by = "Participant_ID") %>%
      #group_by(Participant_ID, association, match, dprime) %>%
      #summarize(count = n()) 
    
    #print(sdt_data2)
    
    #** d' 的方差分析**#
    
    # 获取 data 和 task 的表达式文本（通常是其名称等信息）
    data_name <- deparse(substitute(data))
    task_name <- deparse(substitute(task))

    dprime_file_name <- paste0("dprime_", data_name, "_", task_name, ".doc")
    matching_task_dprime <- sdt %>%
       MANOVA(., dv = "dprime", subID="Participant_ID",
           within = c("association"),
           sph.correction="GG",
           file = file.path(target_folder_path, dprime_file_name)
           )  #%>%
      #emmeans("match", by = "association")
}

# 调用函数
analysis_dprime_matching(data_motion)
analysis_dprime_matching(data_color_secd)
```

## 分别计算一下不同条件的 d'
```{r}
sdt_matching_color_test <- data_color_secd %>% #选择正式实验的数据
  filter(part == "match_RDK") %>%
  group_by(Participant_ID, association) %>%  #按被试与条件分组
  dplyr::mutate(
    type = dplyr::case_when(
      (response == "f" & match == "yes") ~ "hit",
      (response == "j" & match == "no") ~ "cr",
      (response == "j" & match == "yes") ~ "miss",
      (response == "f" & match == "no") ~ "fa")) %>%
  summarize(
    hit = sum(type == "hit"),
    miss = sum(type == "miss"),
    fa = sum(type == "fa"),
    cr = sum(type == "cr"),
    .groups = "drop")
sdt_matching_color_test <- sdt_matching_color_test %>%
  #replace_na(list(hit = 0, miss = 0, cr = 0, fa = 0)) %>%
  #mutate(zhr = qnorm(hit / (hit+miss)),
  #zfa = qnorm(fa / (fa+cr)),
  #dprime = zhr-zfa,
  #crit = -zfa)
  dplyr::mutate(hitR = hit/(hit + miss),  # hit rate
                faR  = fa/(fa+cr)) %>%    # fa rate
  replace_na(list(hitR = 0, faR = 0)) %>%
  # if hit rate is 1, standardize it
  dplyr::mutate(hitR = ifelse(hitR == 1, 1 - 1/(2*(hit + miss)), hitR), 
                # if FA rate is 0, standardize it
                faR  = ifelse(faR == 0, 1/(2*(hit + miss)), faR)) %>% 
  dplyr::mutate(dprime = qnorm(hitR) - qnorm(faR),
                zfa = qnorm(fa / (fa+cr)),
                crit = -zfa
  ) %>%
  mutate( dprime = round(dprime, 2),
          crit = round(crit, 2)
  )
```
         
## 比较在 matching task 中 motion 和 color 的 d' 是否有差异
```{r dprime 比较}

dprime_vs <- function(data) {
  
  # 设置结果的保存路径
  target_folder_path <- "../3_1_Expt_1a/output"
   
   # 计算 motion 的 sdt
   sdt_all <- data %>% #选择正式实验的数据
     filter(part == "match_RDK") %>%
     group_by(Participant_ID, association) %>%  #按被试与条件分组
     dplyr::mutate(
       type = dplyr::case_when(
         (response == "f" & match == "yes") ~ "hit",
         (response == "j" & match == "no") ~ "cr",
         (response == "j" & match == "yes") ~ "miss",
         (response == "f" & match == "no") ~ "fa")) %>%
     summarize(
       hit = sum(type == "hit"),
       miss = sum(type == "miss"),
       fa = sum(type == "fa"),
       cr = sum(type == "cr"),
       .groups = "drop")
    sdt_all <- sdt_all %>%
     #replace_na(list(hit = 0, miss = 0, cr = 0, fa = 0)) %>%
     #mutate(zhr = qnorm(hit / (hit+miss)),
            #zfa = qnorm(fa / (fa+cr)),
            #dprime = zhr-zfa,
            #crit = -zfa)
    dplyr::mutate(hitR = hit/(hit + miss),  # hit rate
                  faR  = fa/(fa+cr)) %>%    # fa rate
    replace_na(list(hitR = 0, faR = 0)) %>%
                  # if hit rate is 1, standardize it
    dplyr::mutate(hitR = ifelse(hitR == 1, 1 - 1/(2*(hit + miss)), hitR), 
                  # if FA rate is 0, standardize it
                  faR  = ifelse(faR == 0, 1/(2*(hit + miss)), faR)) %>% 
    dplyr::mutate(dprime = qnorm(hitR) - qnorm(faR),
                  #zfa = qnorm(fa / (fa+cr)),
                  #crit = -zfa
                  ) %>%
    mutate( dprime = round(dprime, 2),
           # crit = round(crit, 2)
           )
    
    # 根据 id 加上一列新变量，区分 motion 和 color
    sdt_all$group <- ifelse(sdt_all$Participant_ID < 11, "motion", "color")
    
    # 设置为环境变量    
    assign("sdt_all", sdt_all, envir = .GlobalEnv)
    
    #**d' 的方差分析**#
    
    # 获取 data 和 task 的表达式文本（通常是其名称等信息）
    #data_name <- deparse(substitute(data))
  
    dprime_vs <- sdt_all %>%
      MANOVA(., dv = "dprime", subID="Participant_ID",
           within = c("association"),
           between = c("betweenVari"),
           sph.correction="GG",
           file = "dprime_motino_vs_color"
           )  #%>%
      # emmeans("association", by = "betweenVari") # 后面去查一查这个
    
    # 计算画图的数据
    df <- sdt_all %>%
      dplyr::group_by(association, betweenVari) %>%
      dplyr::summarise(mean_d = mean(dprime),
                       sd_d = sd(mean_d),
                       se_d = sd_d/sqrt(n()-1),
                       n = n(),
                       .groups = "drop")
    df2 <- sdt_all %>%
      dplyr::mutate(conds = case_when(association == "other" & betweenVari == "color" ~"0.88",
                                      association == "other" & betweenVari == "motion" ~"1.12",
                                      association == "self" & betweenVari == "color" ~"1.88",
                                      association == "self" & betweenVari == "motion" ~"2.12"),
                    conds = as.numeric(conds))
    
    # 画个交互作用的图
    d_plot2 <- df %>%
      ggplot2::ggplot(.,
                      aes(x = association,
                          y = mean_d,
                          group = betweenVari,
                          color = betweenVari)) +
      ggplot2::geom_line(position = position_dodge(0.5)) +
      ggplot2::geom_point(size = 3,
                          position = position_dodge(0.5)) +
      ggplot2::geom_errorbar(aes(ymin = mean_d - se_d,
                                 ymax = mean_d + se_d),
                             width = .1,
                             position = position_dodge(0.5)) +
      ggplot2::geom_point(data = df2,
                          aes(x = conds, y = dprime, group = betweenVari),
                          position = position_dodge(width = 0.08),
                          alpha = 0.5)
      print(d_plot2)
}

# 调用函数
dprime_vs(data_all)
```

# 信号检测论分析
## RDK task

### 先定义函数

```{r dprime}

analysis_dprime_rdk <- function(data) {
  
  colors <- c("lightblue", "orange")
  
  # 设置保存文件的路径
  target_folder_path <- "../3_1_Expt_1a/output"

    d_plot <- data %>%
    ggplot(., aes(x = difficulty, y = dprime, fill = difficulty, colour = difficulty)) +
    geom_flat_violin(position = position_nudge(x = .2, y = 0), adjust = 2, trim = FALSE, alpha = 0.5) +
    geom_jitter(aes(color = difficulty), width = 0.15) +
    #geom_point(position = position_jitter(width = .15), size = .25, alpha = 0.5) +
    geom_boxplot(aes(x = difficulty, y = dprime), outlier.shape = NA, alpha = 0.5, width = .1, colour = "BLACK") +
    ylab('dprime') + xlab(" ") + coord_flip() +
    theme_cowplot() + #guides(fill = "none", colour = "none") +
    scale_colour_manual(values = colors) + # palette = "Dark2"
    scale_fill_manual(values = colors) # palette = "Dark2"
    #ggtitle("Figure 2a: ACC of ALT2_moral")+
    #guides(fill = guide_legend(title = "参照条件"), colour = guide_legend(title = "参照条件"))
    
    c_plot <- data %>%
    ggplot(., aes(x = difficulty, y = crit, fill = difficulty, colour = difficulty)) +
    geom_flat_violin(position = position_nudge(x = .2, y = 0), trim = FALSE, alpha = 0.5) +
    geom_jitter(aes(color = difficulty), width = 0.15) +
    #geom_point(position = position_jitter(width = .15), size = .25, alpha = 0.5) +
    geom_boxplot(aes(x = difficulty, y = crit), outlier.shape = NA, alpha = 0.5, width = .1, colour = "BLACK") +
    ylab('crit.') + xlab(" ") + coord_flip() +
    theme_cowplot() + #guides(fill = "none", colour = "none") +
    scale_colour_manual(values = colors) + # palette = "Dark2"
    scale_fill_manual(values = colors) # palette = "Dark2"
    #ggtitle("Figure 2a: ACC of ALT2_moral")+
    #guides(fill = guide_legend(title = "参照条件"), colour = guide_legend(title = "参照条件"))
    
    combined_plot <- d_plot + c_plot +
    plot_annotation(title = "color group",
                    theme = theme(plot.title = element_text(size = 30, hjust = 0.5))) 
  
  print(combined_plot)
    
    #sdt_data2 <- data %>%
      #filter(part == "match_RDK") %>%
      #right_join(sdt, by = "Participant_ID") %>%
      #group_by(Participant_ID, association, match, dprime) %>%
      #summarize(count = n()) 
    
    #print(sdt_data2)
  
  #** d' 的方差分析**#
    
    # 获取 data 和 task 的表达式文本（通常是其名称等信息）
    data_name <- deparse(substitute(data))

    dprime_file_name <- paste0(data_name, ".doc")
    rdk_dprime <- data %>%
       MANOVA(., dv = c( "dprime"), subID="Participant_ID",
           within = c("difficulty"),
           sph.correction="GG",
           file = file.path(target_folder_path, dprime_file_name)
           )  #%>%
      #emmeans("match", by = "association")
}
analysis_dprime_rdk(sdt_rdk_color)
```

# 分别计算运动组和颜色组的 d'

```{r}

# 运动组
sdt_rdk_motion_even <- data_motion %>% #选择正式实验的数据
  filter(part == "RDK") %>%
  filter(Participant_ID %% 2 == 0) %>% # 被试id为偶数，左运动代表自己
  group_by(Participant_ID, difficulty) %>%  #按被试与条件分组
  dplyr::mutate(
    # 在这里，把自我定义为信号，他人定义为噪声
    type = dplyr::case_when(
      (response == "arrowleft" & association == "self") ~ "hit",
      (response == "arrowright" & association == "other") ~ "cr",
      (response == "arrowright" & association == "self") ~ "miss",
      (response == "arrowleft" & association == "other") ~ "fa")) %>%
  summarize(
    hit = sum(type == "hit"),
    miss = sum(type == "miss"),
    fa = sum(type == "fa"),
    cr = sum(type == "cr"),
    .groups = "drop")

sdt_rdk_motion_even <- sdt_rdk_motion_even %>%
  dplyr::mutate(hitR = hit/(hit + miss),  # hit rate
                faR  = fa/(fa+cr)) %>%    # fa rate
  replace_na(list(hitR = 0, faR = 0)) %>%
  # if hit rate is 1, standardize it
  dplyr::mutate(hitR = ifelse(hitR == 1, 1 - 1/(2*(hit + miss)), hitR), 
                # if FA rate is 0, standardize it
                faR  = ifelse(faR == 0, 1/(2*(hit + miss)), faR)) %>% 
  dplyr::mutate(dprime = qnorm(hitR) - qnorm(faR),
                zfa = qnorm(fa / (fa+cr)),
                crit = -zfa
  ) %>%
  mutate( dprime = round(dprime, 2),
          crit = round(crit, 2)
  )

sdt_rdk_motion_odd <- data_motion %>% #选择正式实验的数据
  filter(part == "RDK") %>%
  filter(Participant_ID %% 2 == 1) %>% # 被试id为奇数，右运动代表自己
  group_by(Participant_ID, difficulty) %>%  #按被试与条件分组
  dplyr::mutate(
    # 在这里，把自我定义为信号，他人定义为噪声
    type = dplyr::case_when(
      (response == "arrowright" & association == "self") ~ "hit",
      (response == "arrowleft" & association == "other") ~ "cr",
      (response == "arrowleft" & association == "self") ~ "miss",
      (response == "arrowright" & association == "other") ~ "fa")) %>%
  summarize(
    hit = sum(type == "hit"),
    miss = sum(type == "miss"),
    fa = sum(type == "fa"),
    cr = sum(type == "cr"),
    .groups = "drop")

sdt_rdk_motion_odd <- sdt_rdk_motion_odd %>%
  dplyr::mutate(hitR = hit/(hit + miss),  # hit rate
                faR  = fa/(fa+cr)) %>%    # fa rate
  replace_na(list(hitR = 0, faR = 0)) %>%
  # if hit rate is 1, standardize it
  dplyr::mutate(hitR = ifelse(hitR == 1, 1 - 1/(2*(hit + miss)), hitR), 
                # if FA rate is 0, standardize it
                faR  = ifelse(faR == 0, 1/(2*(hit + miss)), faR)) %>% 
  dplyr::mutate(dprime = qnorm(hitR) - qnorm(faR),
                zfa = qnorm(fa / (fa+cr)),
                crit = -zfa
  ) %>%
  mutate( dprime = round(dprime, 2),
          crit = round(crit, 2)
  )

sdt_rdk_motion <- rbind(sdt_rdk_motion_odd, sdt_rdk_motion_even)

# 颜色组
sdt_rdk_color_even <- data_color_secd %>% #选择正式实验的数据
  filter(part == "RDK") %>%
  filter(Participant_ID %% 2 == 0) %>% # 被试id为偶数，red代表自己
  group_by(Participant_ID, difficulty) %>%  #按被试与条件分组
  dplyr::mutate(
    # 在这里，把自我定义为信号，他人定义为噪声
    type = dplyr::case_when(
      (response == "d" & association == "self") ~ "hit",
      (response == "k" & association == "other") ~ "cr",
      (response == "k" & association == "self") ~ "miss",
      (response == "d" & association == "other") ~ "fa")) %>%
  summarize(
    hit = sum(type == "hit"),
    miss = sum(type == "miss"),
    fa = sum(type == "fa"),
    cr = sum(type == "cr"),
    .groups = "drop")

sdt_rdk_color_even <- sdt_rdk_color_even %>%
  dplyr::mutate(hitR = hit/(hit + miss),  # hit rate
                faR  = fa/(fa+cr)) %>%    # fa rate
  replace_na(list(hitR = 0, faR = 0)) %>%
  # if hit rate is 1, standardize it
  dplyr::mutate(hitR = ifelse(hitR == 1, 1 - 1/(2*(hit + miss)), hitR), 
                # if FA rate is 0, standardize it
                faR  = ifelse(faR == 0, 1/(2*(hit + miss)), faR)) %>% 
  dplyr::mutate(dprime = qnorm(hitR) - qnorm(faR),
                zfa = qnorm(fa / (fa+cr)),
                crit = -zfa
  ) %>%
  mutate( dprime = round(dprime, 2),
          crit = round(crit, 2)
  )

sdt_rdk_color_odd <- data_color_secd %>% #选择正式实验的数据
  filter(part == "RDK") %>%
  filter(Participant_ID %% 2 == 1) %>% # 被试id为奇数，blue代表自己
  group_by(Participant_ID, difficulty) %>%  #按被试与条件分组
  dplyr::mutate(
    # 在这里，把自我定义为信号，他人定义为噪声
    type = dplyr::case_when(
      (response == "k" & association == "self") ~ "hit",
      (response == "d" & association == "other") ~ "cr",
      (response == "d" & association == "self") ~ "miss",
      (response == "k" & association == "other") ~ "fa")) %>%
  summarize(
    hit = sum(type == "hit"),
    miss = sum(type == "miss"),
    fa = sum(type == "fa"),
    cr = sum(type == "cr"),
    .groups = "drop")

sdt_rdk_color_odd <- sdt_rdk_color_odd %>%
  dplyr::mutate(hitR = hit/(hit + miss),  # hit rate
                faR  = fa/(fa+cr)) %>%    # fa rate
  replace_na(list(hitR = 0, faR = 0)) %>%
  # if hit rate is 1, standardize it
  dplyr::mutate(hitR = ifelse(hitR == 1, 1 - 1/(2*(hit + miss)), hitR), 
                # if FA rate is 0, standardize it
                faR  = ifelse(faR == 0, 1/(2*(hit + miss)), faR)) %>% 
  dplyr::mutate(dprime = qnorm(hitR) - qnorm(faR),
                zfa = qnorm(fa / (fa+cr)),
                crit = -zfa
  ) %>%
  mutate( dprime = round(dprime, 2),
          crit = round(crit, 2)
  )

sdt_rdk_color <- rbind(sdt_rdk_color_odd, sdt_rdk_color_even) 

sdt_rdk_color <- sdt_rdk_color %>%
  mutate(difficulty = case_when(
      difficulty == "easy" ~ "easy",
      difficulty == "difficult"~ "hard",
      ))
  

```

```{r}
# 颜色组

sdt_rdk_color <- data_color_secd %>% #选择颜色组的数据
  filter(part == "RDK") %>%
  group_by(Participant_ID, association) %>%  #按被试与条件分组
  dplyr::mutate(
    dot_color = dplyr::case_when(
      dot_color_after == '["hsla(0, 50%, 50%, 70%)","hsla(225, 50%, 50%, 70%)"]' ~ "r",
      dot_color_after == '["hsla(225, 50%, 50%, 70%)","hsla(0, 50%, 50%, 70%)"]' ~ "b")) %>%
  dplyr::mutate(
    # 在这里，把红色定义为信号，蓝色定义为噪声
    type = dplyr::case_when(
      (response == "d" & dot_color == "r") ~ "hit",
      (response == "k" & dot_color == "b") ~ "cr",
      (response == "k" & dot_color == "r") ~ "miss",
      (response == "d" & dot_color == "b") ~ "fa")) %>%
  summarize(
    hit = sum(type == "hit"),
    miss = sum(type == "miss"),
    fa = sum(type == "fa"),
    cr = sum(type == "cr"),
    .groups = "drop")

sdt_rdk_color <- sdt_rdk_color %>%
  #replace_na(list(hit = 0, miss = 0, cr = 0, fa = 0)) %>%
  #mutate(zhr = qnorm(hit / (hit+miss)),
  #zfa = qnorm(fa / (fa+cr)),
  #dprime = zhr-zfa,
  #crit = -zfa)
  dplyr::mutate(hitR = hit/(hit + miss),  # hit rate
                faR  = fa/(fa+cr)) %>%    # fa rate
  replace_na(list(hitR = 0, faR = 0)) %>%
  # if hit rate is 1, standardize it
  dplyr::mutate(hitR = ifelse(hitR == 1, 1 - 1/(2*(hit + miss)), hitR), 
                # if FA rate is 0, standardize it
                faR  = ifelse(faR == 0, 1/(2*(hit + miss)), faR)) %>% 
  dplyr::mutate(dprime = qnorm(hitR) - qnorm(faR),
                zfa = qnorm(fa / (fa+cr)),
                crit = -zfa
  ) %>%
  mutate( dprime = round(dprime, 2),
          crit = round(crit, 2)
  )

# 调用函数
analysis_dprime_rdk(sdt_rdk_motion)
#analysis_dprime_rdk(sdt_rdk_color)
```

## 比较在 rdk task 中 motion 和 color 的 d' 是否有差异
```{r dprime 比较}

# 合并之前的数据
sdt_rdk_combined = rbind(sdt_rdk_color, sdt_rdk_motion)

# 根据 id 加上一列新变量，区分 motion 和 color
sdt_rdk_combined$group <- ifelse(sdt_rdk_combined$Participant_ID < 11, "motion", "color")
    
    #**d' 的方差分析**#
    
    # 设置保存文件的路径
  target_folder_path <- "../3_1_Expt_1a/output"
  
    dprime_vs <- sdt_rdk_combined %>%
      MANOVA(., dv = "dprime", subID="Participant_ID",
           within = c("difficulty"),
           between = c("group"),
           sph.correction="GG",
           file = file.path(target_folder_path, "dprime_motino_vs_color_rdk")
           )  #%>%
      # emmeans("association", by = "betweenVari") # 后面去查一查这个
```
    

------------------分割线------------------------------

# 下面的是一些尝试和练习，后面再来修改

## 条形图

```{r}
# #Color
# data <- data %>%
#   filter(Participant_ID %in% c("Exp1A_11", "Exp1A_12", "Exp1A_13"))

# 计算 match_RDK 的平均 RT 和标准误，按 match 分类
summary_data_match_rt <- data_motion %>%
  filter(part == "match_RDK") %>%
  group_by(association, match) %>%
  summarise(mean_rt = mean(rt, na.rm = TRUE),
            se_rt = sd(rt, na.rm = TRUE) / sqrt(n()),
            .groups = 'drop')

# 计算 match_RDK 的正确率，按 match 分类
summary_data_match_acc <- data %>%
  filter(part == "match_RDK") %>%
  group_by(association, match) %>%
  summarise(mean_correct = mean(correct, na.rm = TRUE),
            se_correct = sd(correct, na.rm = TRUE) / sqrt(n()),
            .groups = 'drop')

# 计算 RDK 的平均 RT 和标准误，按 difficulty 分类
summary_data_rdk_rt <- data %>%
  filter(part == "RDK") %>%
  group_by(association, difficulty) %>%
  summarise(mean_rt = mean(rt, na.rm = TRUE),
            se_rt = sd(rt, na.rm = TRUE) / sqrt(n()),
            .groups = 'drop')

# 计算 RDK 的正确率，按 difficulty 分类
summary_data_rdk_acc <- data %>%
  filter(part == "RDK") %>%
  group_by(association, difficulty) %>%
  summarise(mean_correct = mean(correct, na.rm = TRUE),
            se_correct = sd(correct, na.rm = TRUE) / sqrt(n()),
            .groups = 'drop')

# 设置颜色主题
cbp <- ggokabeito::scale_okabe_ito(aesthetics = c("color", "fill", "edge_colour"),
                                   order = c(1, 2, 7, 3:6))


# 绘制 match_RDK 的 RT 条形图，按 association 分类
p1 <- ggplot(summary_data_match_rt, aes(x = match, y = mean_rt, fill = association)) +
  geom_col(color = "black", width = 0.35, position = position_dodge(width = 0.4)) +  # 缩小距离
  geom_errorbar(aes(ymin = mean_rt - se_rt, ymax = mean_rt + se_rt), 
                width = 0.2, position = position_dodge(width = 0.4)) +  # 缩小距离
  labs(x = "Identity", y = "Reaction Times (ms)", title = "Task 1: Match RDK") +
  coord_cartesian(ylim = c(0, max(summary_data_match_rt$mean_rt + summary_data_match_rt$se_rt, na.rm = TRUE))) +
  cbp +
  theme_minimal() +
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_text(size = 12, face = "bold"))

# 绘制 match_RDK 的 ACC 条形图，按 association 分类
p2 <- ggplot(summary_data_match_acc, aes(x = match, y = mean_correct, fill = association)) +
  geom_col(color = "black", width = 0.35, position = position_dodge(width = 0.4)) +  # 缩小距离
  geom_errorbar(aes(ymin = mean_correct - se_correct, ymax = mean_correct + se_correct), 
                width = 0.2, position = position_dodge(width = 0.4)) +  # 缩小距离
  labs(x = "Identity", y = "Accuracy", title = "Task 1: Match RDK") +
  coord_cartesian(ylim = c(0.8, 1)) +
  cbp +
  theme_minimal() +
  # coord_cartesian(ylim = c(0.8, 1)) +   (这里重复了可以去掉)
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_text(size = 12, face = "bold"))

# 绘制 RDK 的 RT 条形图，按 association 分类
p3 <- ggplot(summary_data_RDK_rt, aes(x = difficulty, y = mean_rt, fill = association)) +
  geom_col(color = "black", width = 0.35, position = position_dodge(width = 0.4)) +  # 缩小距离
  geom_errorbar(aes(ymin = mean_rt - se_rt, ymax = mean_rt + se_rt), 
                width = 0.2, position = position_dodge(width = 0.4)) +  # 缩小距离
  labs(x = "Identity", y = "Reaction Times (ms)", title = "Task 2: RDK") +
  coord_cartesian(ylim = c(0, max(summary_data_RDK_rt$mean_rt + summary_data_RDK_rt$se_rt, na.rm = TRUE))) +
  cbp +
  theme_minimal() +
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_text(size = 12, face = "bold"))

# 绘制 RDK 的 ACC 条形图，按 association 分类
p4 <- ggplot(summary_data_RDK_acc, aes(x = difficulty, y = mean_correct, fill = association)) +
  geom_col(color = "black", width = 0.35, position = position_dodge(width = 0.4)) +  # 缩小距离
  geom_errorbar(aes(ymin = mean_correct - se_correct, ymax = mean_correct + se_correct), 
                width = 0.2, position = position_dodge(width = 0.4)) +  # 缩小距离
  labs(x = "Identity", y = "Accuracy", title = "Task 2: RDK") +
  coord_cartesian(ylim = c(0.6, 1)) +
  cbp +
  theme_minimal() +
  # coord_cartesian(ylim = c(0.6, 1)) + (这里重复了可以去掉)
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_text(size = 12, face = "bold"))

# 合并四个图形
combined_plot <- plot_grid(p1, p2, p3, p4, align = "hv", ncol = 2)
print(combined_plot)

# 清理环境
# rm(cbp, combined_plot, p1, p2, p3, p4, summary_data_match_rt, summary_data_match_acc, summary_data_RDK_rt, summary_data_RDK_acc)

```

## Color
```{r}
library(ggplot2)
library(dplyr)
library(ggokabeito)
library(cowplot)
# library(papaja)


# 计算 match_RDK 的平均 RT 和标准误，按 match 分类
summary_data_match_rt <- data %>%
  #filter(part == "match_RDK") %>%
  group_by(part, difficuty) %>%
  summarise(mean_rt = mean(rt, na.rm = TRUE),
            se_rt = sd(rt, na.rm = TRUE) / sqrt(n()),
            .groups = 'drop')

# 计算 match_RDK 的正确率，按 match 分类
summary_data_match_acc <- data %>%
  #filter(part == "match_RDK") %>%
  group_by(part, difficuty) %>%
  summarise(mean_correct = mean(correct, na.rm = TRUE),
            se_correct = sd(correct, na.rm = TRUE) / sqrt(n()),
            .groups = 'drop')


# 设置颜色主题
cbp <- ggokabeito::scale_okabe_ito(aesthetics = c("color", "fill", "edge_colour"),
                                   order = c(1, 2, 7, 3:6))


# 绘制 match_RDK 的 RT 条形图，按 association 分类
p1 <- ggplot(summary_data_match_rt, aes(x = match, y = mean_rt, fill = association)) +
  geom_col(color = "black", width = 0.35, position = position_dodge(width = 0.4)) +  # 缩小距离
  geom_errorbar(aes(ymin = mean_rt - se_rt, ymax = mean_rt + se_rt), 
                width = 0.2, position = position_dodge(width = 0.4)) +  # 缩小距离
  labs(x = "Identity", y = "Reaction Times (ms)", title = "Task 1: Match RDK") +
  coord_cartesian(ylim = c(0, max(summary_data_match_rt$mean_rt + summary_data_match_rt$se_rt, na.rm = TRUE))) +
  cbp +
  theme_minimal() +
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_text(size = 12, face = "bold"))

# 绘制 match_RDK 的 ACC 条形图，按 association 分类
p2 <- ggplot(summary_data_match_acc, aes(x = match, y = mean_correct, fill = association)) +
  geom_col(color = "black", width = 0.35, position = position_dodge(width = 0.4)) +  # 缩小距离
  geom_errorbar(aes(ymin = mean_correct - se_correct, ymax = mean_correct + se_correct), 
                width = 0.2, position = position_dodge(width = 0.4)) +  # 缩小距离
  labs(x = "Identity", y = "Accuracy", title = "Task 1: Match RDK") +
  coord_cartesian(ylim = c(0.8, 1)) +
  cbp +
  theme_minimal() +
  # coord_cartesian(ylim = c(0.8, 1)) +   (这里重复了可以去掉)
  theme(legend.position = "top", 
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_text(size = 12, face = "bold"))

# 绘制 RDK 的 RT 条形图，按 association 分类
p3 <- ggplot(summary_data_RDK_rt, aes(x = difficulty, y = mean_rt, fill = association)) +
  geom_col(color = "black", width = 0.35, position = position_dodge(width = 0.4)) +  # 缩小距离
  geom_errorbar(aes(ymin = mean_rt - se_rt, ymax = mean_rt + se_rt), 
                width = 0.2, position = position_dodge(width = 0.4)) +  # 缩小距离
  labs(x = "Identity", y = "Reaction Times (ms)", title = "Task 2: RDK") +
  coord_cartesian(ylim = c(0, max(summary_data_RDK_rt$mean_rt + summary_data_RDK_rt$se_rt, na.rm = TRUE))) +
  cbp +
  theme_minimal() +
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_text(size = 12, face = "bold"))

# 绘制 RDK 的 ACC 条形图，按 association 分类
p4 <- ggplot(summary_data_RDK_acc, aes(x = difficulty, y = mean_correct, fill = association)) +
  geom_col(color = "black", width = 0.35, position = position_dodge(width = 0.4)) +  # 缩小距离
  geom_errorbar(aes(ymin = mean_correct - se_correct, ymax = mean_correct + se_correct), 
                width = 0.2, position = position_dodge(width = 0.4)) +  # 缩小距离
  labs(x = "Identity", y = "Accuracy", title = "Task 2: RDK") +
  coord_cartesian(ylim = c(0.6, 1)) +
  cbp +
  theme_minimal() +
  # coord_cartesian(ylim = c(0.6, 1)) +   (这里重复了，可以去掉) 
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_text(size = 12, face = "bold"))

# 合并四个图形
combined_plot <- plot_grid(p1, p2, p3, p4, align = "hv", ncol = 2)
print(combined_plot)

# 清理环境
# rm(cbp, combined_plot, p1, p2, p3, p4, summary_data_match_rt, summary_data_match_acc, summary_data_RDK_rt, summary_data_RDK_acc)

```



### 带统计结果的小提琴图
```{r}

matching_task_analysis<-function(data){
  # 计算所需要的数据
  df <- data %>% #选择正式实验的数据
    #filter(part == "match_RDK") %>%
      group_by(part, difficuty) %>%  #按被试与匹配条件分组
        summarise(
          avg_rt = mean(rt, na.rm = TRUE),#每个被试所有trial的平均反应时
          max_rt = max(rt, na.rm = TRUE),#每个被试所有trial的最大反应时
          min_rt = min(rt, na.rm = TRUE),#每个被试所有trial的最小反应时
          sd_rt = sd(rt, na.rm = TRUE), #每个被试所有trial的反应时的方差
          all_count = n(),#每个被试在每个条件的总trial数量
          row_count = sum(rt>=200 & rt <=1200, na.rm = TRUE), #舍弃按键太快和按键太慢的反应时
          correct_count = sum(correct == 1 & rt>=200 & rt <=1200, na.rm = TRUE),
          acc = correct_count /all_count,
          .groups = "drop")  #计算每个被试在每个条件的正确率= 正确/总数
  
  print(df)
  
  # 绘制正确率的图
  acc_plot <- ggstatsplot::ggwithinstats(
  data = df,
  x = match,
  y = acc,
  results.subtitle = FALSE,
  bf.message = FALSE,
  xlab = " ",
  ylab = "ACC",
  title = "Match Condition"
  ) + # modifying the plot further
  ggplot2::scale_y_continuous(
    limits = c(0.85, 1),
    breaks = seq(from = 0.85, to = 1, by = 0.05),
  ) +
  theme(
    axis.ticks = element_blank(),
    axis.line = element_line(colour = "grey50"),
    panel.grid = element_line(color = "#b4aea9"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.major.y = element_line(linetype = "dashed"),
    #panel.background = element_rect(fill = "#fbf9f4", color = "#fbf9f4"),
    #plot.background = element_rect(fill = "#fbf9f4", color = "#fbf9f4")
  )
  print(acc_plot)
  
  # 绘制反应时的图 （反应时 vs. 正确反应时?）
  rt_plot <- ggstatsplot::ggwithinstats(
  data = matching_task_data1,
  x = match,
  y = avg_rt,
  bf.message = FALSE,
  xlab = " ",
  ylab = "RT (ms)",
  #title = "RT of Matching Task"
  ) + # modifying the plot further
  ggplot2::scale_y_continuous(
    limits = c(800, 1100),
    breaks = seq(from = 800, to = 1100, by = 100),
  ) +
  theme(
    axis.ticks = element_blank(),
    axis.line = element_line(colour = "grey50"),
    panel.grid = element_line(color = "#b4aea9"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.major.y = element_line(linetype = "dashed"),
    #panel.background = element_rect(fill = "#fbf9f4", color = "#fbf9f4"),
    #plot.background = element_rect(fill = "#fbf9f4", color = "#fbf9f4")
  )
  print(rt_plot)
  
  # Combine plots vertically
  #final_plot <- acc_plot + rt_plot #+ plot_layout(guides = "collect") 
  final_plot <- plot_grid(acc_plot, 
                          NULL,
                          NULL,
                          rt_plot,
                          nrow = 4,
                          #rel_widths = c(1, 0.01, 1),
                          rel_heights = c(1, 0.01, 0.01, 1)
                          )
  #print(final_plot)
  
  #输出保存到文件夹
  ggsave("fig1_matching_task.png", final_plot, width = 10, height = 8, dpi = 300)
  
  # 计算新的数据（包括所有被试的平均正确率和平均反应时）
  matching_task_data2 <- data %>%
    filter(part == "match_RDK") %>%
    group_by(Participant_ID, association) %>%  #按被试与条件分组
    summarise(
      avg_rt = mean(rt, na.rm = TRUE), sd_rt=sd(rt, na.rm = TRUE),
      max_rt = max(rt, na.rm = TRUE), min_rt = min(rt, na.rm = TRUE),
      all_count=n(), row_count = sum(rt>=200 & rt <=1200, na.rm = TRUE),
      correct_count = sum(correct == 1 & rt>=200 & rt <=1200, na.rm = TRUE),
      acc = correct_count /all_count,
      .groups = "drop"
      ) 
  print(matching_task_data2)
  
  # 绘制正确率的图
  acc_plot2 <- ggstatsplot::ggwithinstats(
  data = matching_task_data2,
  x = association,
  y = acc,
  bf.message = FALSE,
  xlab = " ",
  ylab = "ACC",
  title = "Association Condition"
  ) + # modifying the plot further
  ggplot2::scale_y_continuous(
    limits = c(0.85, 1),
    breaks = seq(from = 0.85, to = 1, by = 0.05),
  ) +
  theme(
    axis.ticks = element_blank(),
    axis.line = element_line(colour = "grey50"),
    panel.grid = element_line(color = "#b4aea9"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.major.y = element_line(linetype = "dashed"),
    #panel.background = element_rect(fill = "#fbf9f4", color = "#fbf9f4"),
    #plot.background = element_rect(fill = "#fbf9f4", color = "#fbf9f4")
  )
  print(acc_plot2)
  
  # 绘制反应时的图 
  rt_plot2 <- ggstatsplot::ggwithinstats(
  data = matching_task_data2,
  x = association,
  y = avg_rt,
  bf.message = FALSE,
  xlab = " ",
  ylab = "RT (ms)",
  #title = "ACC of Matching Task"
  ) + # modifying the plot further
  ggplot2::scale_y_continuous(
    limits = c(700, 1100),
    breaks = seq(from = 700, to = 1100, by = 100),
  ) +
  theme(
    axis.ticks = element_blank(),
    axis.line = element_line(colour = "grey50"),
    panel.grid = element_line(color = "#b4aea9"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.major.y = element_line(linetype = "dashed"),
    #panel.background = element_rect(fill = "#fbf9f4", color = "#fbf9f4"),
    #plot.background = element_rect(fill = "#fbf9f4", color = "#fbf9f4")
  )
  print(rt_plot2)
  
  # 合并四个图形
  combined_plot <- plot_grid(acc_plot, rt_plot,
                             acc_plot2, rt_plot2,
                             align = "hv", ncol = 2)
  print(combined_plot)
  
}
matching_task_analysis(data_motion)
```


































# Pass
# 读取目录下数据 jspsych-matching-tasks
```{r}
# 设置目标文件夹相对路径
folder_path <- "../2_Experiments/2_1_Pilot_Experiment/2_2_2_RawData/RawData"

# 列出所有含有"Exp1A_"的csv文件
file_list <- list.files(path = folder_path, pattern = "*_matching-task1.*\\.csv$", full.names = TRUE)

# 创建一个空列表来存储数据
df_list_2 <- list()

# 逐个读取文件并存储
for (file in file_list) {
  file_name <- tools::file_path_sans_ext(basename(file))  # 获取文件名（不带扩展名）
  df_list_2[[file_name]] <- read.csv(file)  # 将数据存储在列表中
}
rm(file,file_list,file_name,folder_path)
```

# 数据清洗 jspsych-matching-tasks
```{r}

```

