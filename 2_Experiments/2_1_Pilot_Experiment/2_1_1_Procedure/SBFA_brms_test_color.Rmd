---
title: "采用贝叶斯序列分析确定样本量"
date: "`r format(Sys.Date(), '%Y-%m-%d')`"
documentclass: ctexart
geometry: "left=2cm,right=2cm,top=2cm,bottom=2cm"
output:
  html_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
editor_options: 
  markdown: 
    wrap: 72
---

**markdown的内容：数据预处理 + BF 值计算**

-   数据预处理
    -   剔除极端值
    -   分组计算 RT, ACC, d prime
    -   将得到的数据以新的 csv 文件输出
-   BF 值计算

------------------------------------------------------------------------

-   研究中的关键效应

| 研究问题                                       | 统计假设                                                                                           | 因变量                              | 可能的 BF 值（加粗为关键）                                                         |
|-----------------|-----------------|-----------------|-----------------------|
| 自我关联是否对知觉判断中不同难度的试次产生影响 | 知觉难度与自我相关性的交互作用<br>知觉难度与自我相关性的交互作用<br>知觉难度与自我相关性的交互作用 | **RT**<br>ACC<br> ***d*** **prime** | **2×4 RM ANOVA 中的交互作用**<br>2×4 RM ANOVA 中的交互作用<br>**One way RM ANOVA** |

-   停止规则：
    -   贝叶斯因子阈值确定为10
    -   最小样本量40，最大样本量70

```{r}
rm(list = ls())
```

下载和安装需要的R语言程序包

```{r message=FALSE, warning=FALSE}
# install.packages(c("tidyverse", "BayesFactor", "here"))
library(BayesFactor)#计算t检验和方差分析的贝叶斯因子
library(brms)
library(tidyverse)
library(showtext)#解决中文字体无法显示问题
library(latex2exp)#latex语法
# font_add("song", 
         # "/System/Library/Fonts/Supplemental/Songti.ttc")
##从系统增加宋体字
showtext_auto()
library(here)
here()
options(scipen = 9)#将科学计数法改为在万后9位
set.seed(1234)
```

BayesFacotr包版本

```{r}
packageVersion("brms")
```

# 数据预处理

## 读取原始数据

```{r}
# 文件路径和文件名根据实际情况调整
# 设置目标文件夹相对路径
folder_path <- "../2_1_2_RawData/pilot_expt_all"

# 列出所有含有"pilot_expt_v4_"的csv文件
file_list <- list.files(
  path = folder_path,
  pattern = "*pilot_expt_0421_.*\\.csv$", full.names = TRUE
)

# 创建一个空列表来存储数据
df_list_1 <- list()

# 逐个读取文件并存储
for (file in file_list) {
  file_name <- tools::file_path_sans_ext(basename(file))  # 获取文件名（不带扩展名）
  df_list_1[[file_name]] <- read.csv(file)  # 将数据存储在列表中
}
#rm(file, file_list, folder_path)
```

## 数据清洗

```{r}
# 创建输出文件夹（如果不存在）
output_path <- "../2_1_3_CleanData/pilot_expt_all"
if (!dir.exists(output_path)) {
  dir.create(output_path, recursive = TRUE)
}

# 逐篇处理每个数据框
for (file_name in names(df_list_1)) {
  data <- df_list_1[[file_name]]

  # 提取被试信息
  participant_info <- data[data$part == "survey", "response"]
  participant_info <- gsub("[{}\"]", "", participant_info) # 去掉多余的字符
  info_list <- strsplit(participant_info, ",")[[1]]

  # 创建新的变量
  participant_data <- data.frame(
    subj_idx = file_name,
    Sex = as.character(NA),
    Age = as.numeric(NA),
    Handedness = as.character(NA),
    Color_blindness = as.character(NA),
    stringsAsFactors = FALSE
  )
  
  # 先按照下划线分割字符串
  split_data <- strsplit(participant_data$subj_idx, "_")
  # 提取分割后的第四个元素（数字部分在第四个位置，可根据实际调整）并转换为数值
  participant_data$subj_idx <- as.numeric(lapply(split_data, function(x) substr(x[[4]], 1, 2)))

  for (info in info_list) {
    key_value <- strsplit(info, ":")[[1]]
    key <- trimws(key_value[1])
    value <- trimws(key_value[2])
    if (key == "sex") participant_data$Sex <- value
    if (key == "age") participant_data$Age <- as.numeric(value)
    if (key == "hands") participant_data$Handedness <- value
    if (key == "color_blindness") participant_data$Color_blindness <- value
  }

  # 提取行为数据
  behavior_data <- data[
    data$part %in% c("motion_test","match_RDK","RDK"),
    c(
      "part", "rt", "response", "correct", "coherent_direction","coherence",
      "isMatch", "association", "difficulty", "dot_color_final","target_color_proportion"
    )
  ]
  
  # 分别提取正式试次
  official_trials <- do.call(
    rbind,
    lapply(unique(behavior_data$part), function(part) {
      part_data <- behavior_data[behavior_data$part == part, ]
      if (part == "match_RDK") {
        return(tail(part_data, 384)) # 匹配任务384次
      } else if (part == "RDK") {
        return(tail(part_data, 192)) # 辨别任务192次
      } else {
        return(NULL)
      }
    })
  )

  # 合并被试信息和行为数据
  final_data <- cbind(participant_data, official_trials)

  # 输出到新的CSV文件
  output_file <- file.path(output_path, paste0(file_name, "_Clean.csv"))
  write.csv(final_data, output_file, row.names = FALSE)
}
```

## 读取清洗后的数据

```{r message=FALSE}
# 设置目标文件夹相对路径
folder_path <- "../2_1_3_CleanData/pilot_expt_all"

# 列出所有含有"pilot_expt_"的csv文件
file_list <- list.files(
  path = folder_path,
  pattern = "*pilot_expt_0421_.*\\.csv$", full.names = TRUE
)

# 创建一个空列表来存储数据
df_list_1 <- list()

# 逐个读取文件并存储
for (file in file_list) {
  file_name <- tools::file_path_sans_ext(basename(file)) # 获取文件名（不带扩展名）
  df_list_1[[file_name]] <- read.csv(file) # 将数据存储在列表中
}

# 清除不需要的变量
rm(output_path, participant_info, info_list, participant_data, split_data,
   behavior_data, official_trials, final_data, output_file, file, file_list,
   file_name, folder_path, info, key, key_value, value)

# 把 df_list_1 传送给 data
data <- do.call(rbind, df_list_1)
```

## 分组计算RT, ACC

定义函数，用来计算不同条件下的平均反应时和正确率

```{r}
# 计算平均正确率和反应时
copmute_rt_acc <- function(data){
  data <- data %>%
  filter(part %in% c("match_RDK","RDK")) %>%
    group_by(subj_idx, part, difficulty, association) %>%  #按被试与难度和关联类型分组
    summarise(
      rt = mean(rt, na.rm = TRUE),#每个被试所有trial的平均反应时
      rt_max = max(rt, na.rm = TRUE),#每个被试所有trial的最大反应时
      rt_min = min(rt, na.rm = TRUE),#每个被试所有trial的最小反应时
      sd_rt = sd(rt, na.rm = TRUE), #每个被试所有trial的反应时的方差
      all_count = n(),#每个被试在每个条件的总trial数量
      row_count = sum(rt >= 200 & rt <= 3000, na.rm = TRUE), #舍弃按键太快和按键太慢的反应时
      correct_count = sum(correct == 'true' & rt >= 200 & rt <= 3000, na.rm = TRUE),
      acc = correct_count /all_count, #计算每个被试在每个条件的正确率= 正确/总数
      .groups = "drop")
   
    # 返回处理后的数据
    return(data)
}
```

```{r}
# 计算自我-他人的平均正确率和反应时
copmute_rt_acc_diff <- function(data){
  # 先按subj_idx, part, difficulty聚合，确保self和other数据在同一组内
  data_agg <- data %>%
    filter(part %in% c("match_RDK","RDK")) %>%
    group_by(subj_idx, part, difficulty) %>%
    summarise(
      rt_other = mean(rt[association == "other"], na.rm = TRUE),
      rt_self = mean(rt[association == "self"], na.rm = TRUE),
      acc_other = mean(acc[association == "other"], na.rm = TRUE),
      acc_self = mean(acc[association == "self"], na.rm = TRUE),
      .groups = "drop"
    )
  
  # 计算差值
  data_result <- data_agg %>%
    mutate(
      rt_diff_so = rt_self - rt_other, # so = self - other
      acc_diff_so = acc_self - acc_other
    )
  
  return(data_result)
}
```

```{r}
data <- data %>%
  #筛出反应时在200~3000)
  filter(rt >= 200 & rt <= 3000)

# Motion
data1 <- data %>%
  filter(
    subj_idx %in% c( seq(21, 40))) # 被试编号 1-20 为颜色组

data_color_rt_acc <- copmute_rt_acc(data1) %>%
  dplyr::mutate(group = "color")

data_color_rt_acc_diff <- copmute_rt_acc_diff(data_color_rt_acc)
```

## 数据整理

### RT

#### 匹配任务


```{r}
#分析因变量为RT的使用数据
df_rt_color_match <- data_color_rt_acc %>%
  filter(part %in% c('match_RDK')) %>%
  #选择被试信息以及RT_开头的列
  dplyr::select(subj_idx, rt, association, difficulty, group) %>%
  # 添加新列 dv_name，值为 RT
  dplyr::mutate(dv_name = "RT") %>%
  #类型为character的转换为因子类型，便于后续分析
  mutate(subj_idx = as.factor(subj_idx),
         association = as.factor(association),
         difficulty = as.factor(difficulty))

df_rt_color_diff_match <- data_color_rt_acc_diff %>%
  # 只选择难度为1 和 4 的
  filter(difficulty %in% c(1, 4), part %in% c('match_RDK')) %>%
  #选择被试信息以及RT_开头的列
  dplyr::select(subj_idx, rt_diff_so, difficulty) %>%
  # 添加新列 dv_name，值为 RT
  dplyr::mutate(dv_name = "RT_diff") %>%
  #类型为character的转换为因子类型，便于后续分析
  mutate(subj_idx = as.factor(subj_idx),
         difficulty = as.factor(difficulty)) %>%
  tidyr::pivot_wider(names_from = difficulty, values_from = rt_diff_so) %>%
  dplyr::rename(easiest = `1`, hardest = `4`)

head(df_rt_color_match, 13)
```

#### 辨别任务
```{r}
#分析因变量为RT的使用数据
df_rt_color_rdk <- data_color_rt_acc %>%
  filter(part %in% c('RDK')) %>%
  #选择被试信息以及RT_开头的列
  dplyr::select(subj_idx, rt, association, difficulty, group) %>%
  # 添加新列 dv_name，值为 RT
  dplyr::mutate(dv_name = "RT") %>%
  #类型为character的转换为因子类型，便于后续分析
  mutate(subj_idx = as.factor(subj_idx),
         association = as.factor(association),
         difficulty = as.factor(difficulty))

df_rt_color_diff_rdk <- data_color_rt_acc_diff %>%
  # 只选择难度为1 和 4 的
  filter(difficulty %in% c(1, 4), part %in% c('RDK')) %>%
  #选择被试信息以及RT_开头的列
  dplyr::select(subj_idx, rt_diff_so, difficulty) %>%
  # 添加新列 dv_name，值为 RT
  dplyr::mutate(dv_name = "RT_diff") %>%
  #类型为character的转换为因子类型，便于后续分析
  mutate(subj_idx = as.factor(subj_idx),
         difficulty = as.factor(difficulty)) %>%
  tidyr::pivot_wider(names_from = difficulty, values_from = rt_diff_so) %>%
  dplyr::rename(easiest = `1`, hardest = `4`)

head(df_rt_color_rdk)
```

### ACC

#### 匹配任务

```{r}
df_acc_color_match <- data_color_rt_acc %>% 
  filter(part %in% c('match_RDK')) %>%
  dplyr::select(subj_idx, acc, association, difficulty, group) %>%
  # 添加新列 dv_name，值为 ACC
  dplyr::mutate(dv_name = "ACC") %>%
  #类型为character的转换为因子类型，便于后续分析
  mutate(subj_idx = as.factor(subj_idx),
         association = as.factor(association),
         difficulty = as.factor(difficulty))

df_acc_color_diff_match <- data_color_rt_acc_diff %>%
  # 只选择难度为1 和 4 的
  filter(difficulty %in% c(1, 4), 
         part %in% c('match_RDK')) %>%
  #选择被试信息以及RT_开头的列
  dplyr::select(subj_idx, acc_diff_so, difficulty) %>%
  # 添加新列 dv_name，值为 RT
  dplyr::mutate(dv_name = "ACC_diff") %>%
  #类型为character的转换为因子类型，便于后续分析
  mutate(subj_idx = as.factor(subj_idx),
         difficulty = as.factor(difficulty)) %>%
  tidyr::pivot_wider(names_from = difficulty, values_from = acc_diff_so) %>%
  dplyr::rename(easiest = `1`, hardest = `4`)

head(df_acc_color_match, 20)
```

#### 辨别任务

```{r}
df_acc_color_rdk <- data_color_rt_acc %>% 
  filter(part %in% c('RDK')) %>%
  dplyr::select(subj_idx, acc, association, difficulty, group) %>%
  # 添加新列 dv_name，值为 ACC
  dplyr::mutate(dv_name = "ACC") %>%
  #类型为character的转换为因子类型，便于后续分析
  mutate(subj_idx = as.factor(subj_idx),
         association = as.factor(association),
         difficulty = as.factor(difficulty))

df_acc_color_diff_rdk <- data_color_rt_acc_diff %>%
  # 只选择难度为1 和 4 的
  filter(difficulty %in% c(1, 4), part %in% c('RDK')) %>%
  #选择被试信息以及RT_开头的列
  dplyr::select(subj_idx, acc_diff_so, difficulty) %>%
  # 添加新列 dv_name，值为 RT
  dplyr::mutate(dv_name = "ACC_diff") %>%
  #类型为character的转换为因子类型，便于后续分析
  mutate(subj_idx = as.factor(subj_idx),
         difficulty = as.factor(difficulty)) %>%
  tidyr::pivot_wider(names_from = difficulty, values_from = acc_diff_so) %>%
  dplyr::rename(easiest = `1`, hardest = `4`)

head(df_acc_color_rdk, 20)
```

# BF 值计算
## 匹配任务
### 重复测量方差分析
####  ACC
```{r}
# 使用逐次差分对比编码对 association 和 difficulty 进行编码
contrasts(df_acc_color_match$association) <- MASS::contr.sdif(2) # association 有两水平

# 修改 difficulty 变量的参考水平为 2
df_acc_color_match$difficulty <- relevel(df_acc_color_match$difficulty, ref = "2")

# contrasts(df_acc_motion_match$difficulty) <- MASS::contr.sdif(4) # difficulty 有四水平



# 查看新的对比矩阵
print("新的对称差异对比矩阵：")
print(contrasts(df_acc_color_match$association))
print(contrasts(df_acc_color_match$difficulty))
```

```{r}
## 定义先验分布  
prior_01 <- c(
  # prior(cauchy(0, 0.7), class = Intercept),
  prior(cauchy(0, 0.7), class = Intercept),
  prior(cauchy(0, 0.7), class = b),
  # prior(normal(0, 0.5), class = sigma),
  # prior(normal(0, 0.5), class = sd),
  prior(lkj(2), class = cor)
)
```

```{r}
acc_match_m <- df_acc_color_match %>%
  brms::brm(acc ~ association*difficulty +
            (1 + difficulty | subj_idx),
            iter = 4000,
            data = .,
            prior = prior_01,
            sample_prior = 'only'
            )
```
```{r}
pp_check(acc_match_m, type = "stat", stat = "min", prefix = "ppd")
pp_check(acc_match_m, type = "stat", stat = "max", prefix = "ppd")  
pp_check(acc_match_m, type = "stat", stat = "mean", prefix = "ppd")
```

```{r}
acc_match_m <- df_acc_color_match %>%
  brms::brm(acc ~ association*difficulty +
            (1 + difficulty | subj_idx),
            iter = 4000,
            data = .,
            prior = prior_01,
            sample_prior = 'yes'
            )
```

```{r}
summary(acc_match_m)
acc_match_m$prior
```

**对结果的解读：**

  - Intercept是模型的固定截距，表示所有被试的平均正确率；
  - association2M1表示在平均(控制）难度水平的效应之后，self - other的差值，即association的主效应
  - difficulty主效应显著，难度增加，acc降低，尤其在难度水平 4 时更明显
  - 交互效应中，association2M1:difficulty2 和 association2M1:difficulty4显著，意味着高难度下association不同水平对acc影响差异明显，association2M1:difficulty3不显著

## hypothesis-bf
### 提取出最关键的假设
self vs. other 在最难条件下对 acc 的影响大于 self vs. other 在最容易条件下对 acc 的影响

```{r}
# result <- hypothesis(acc_match_m, 'association2M1:difficulty4 < association2M1')
result <- hypothesis(acc_match_m, 'association2M1:difficulty4 = association2M1:difficulty1')
result
result$hypothesis$Evid.Ratio
```

数据的基本信息
```{r}
subj_num <- unique(df_acc_color_match$subj_idx) # 每个被试的编号
n <- length(unique(df_acc_color_match$subj_idx)) # 被试数量
n
```

```{r}
# 生成三个向量用来储存两个主效应和交互项的贝叶斯因子
BFs_difficulty <- rep(1, length(subj_num))
BFs_association <- rep(1, length(subj_num))
BFs_int <- rep(1, length(subj_num))

# 用于存储每个循环中拟合的模型
models <- list()

for (i in seq_along(subj_num)) {
  if (i == 1) {
    next
  }
  # 将 subj_idx 转换为字符型
  df_acc_color_match$subj_idx <- as.character(df_acc_color_match$subj_idx)
  # 选择前 i 个受试者的唯一索引
  id <- unique(df_acc_color_match$subj_idx)[1:i]
  # 筛选出所选受试者的数据
  df.selected <- df_acc_color_match %>% dplyr::filter(subj_idx %in% id)
  # 将相关变量转换为因子型
  df.selected$subj_idx <- as.factor(df.selected$subj_idx)
  df.selected$difficulty <- as.factor(df.selected$difficulty)
  df.selected$association <- as.factor(df.selected$association)
  
  # 拟合 brms 模型
  acc_match_m <- df.selected %>%
    brms::brm(acc ~ association*difficulty +
                (1 + association*difficulty | subj_idx),
              family = gaussian(),
              iter = 4000,
              data = .,
              sample_prior = 'yes',
              cores = parallel::detectCores()
    )
  
  # 将拟合的模型存储到列表中
  models[[i]] <- acc_match_m
  
  # 进行假设检验并计算贝叶斯因子
  # 这里我们要检验 association 主效应、difficulty 主效应和交互项
  # 检验 association 主效应
  result_association <- hypothesis(acc_match_m, 'association2M1 > 0')
  BF_association <- result_association$hypothesis$Evid.Ratio
  
  
  # 检验交互项
  result_int <- hypothesis(acc_match_m, 'association2M1:difficulty4 > association2M1:difficulty1')
  BF_int <- result_int$hypothesis$Evid.Ratio
  
  # 将计算得到的贝叶斯因子存储到相应向量中
  BFs_association[i] <- BF_association
  BFs_int[i] <- BF_int
}
```

```{r}
# 整合为数据框
aov_output <- tibble::tibble(BFs_int, BFs_association, BFs_difficulty)
# 查看数据
head(aov_output, 20)
```
得到的结果和 BayesFactor 包得到的结果相差较大。

- 可能的原因，两个包的默认先验不一样
  - 先验为 normal(0, 0.5)，交互项的BF值为5.34
  - 先验为 cauchy(0, 0.7)，交互项的BF值为5.41
  
```{r}
summary(acc_match_m)
```


```{r}
interactions::cat_plot(model = acc_match_m,
                       pred = difficulty,
                       modx = association)
```